<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>vue相关的面试题 | 前端知识体库</title>
    <meta name="description" content="">
    <meta name="generator" content="VuePress 1.3.0">
    <link rel="icon" href="/img/favicon.ico">
    
    <link rel="preload" href="/assets/css/0.styles.b71a9117.css" as="style"><link rel="preload" href="/assets/js/app.ab23b884.js" as="script"><link rel="preload" href="/assets/js/2.11e16805.js" as="script"><link rel="preload" href="/assets/js/3.4d4ab6c0.js" as="script"><link rel="prefetch" href="/assets/js/10.4429eb72.js"><link rel="prefetch" href="/assets/js/11.ee86e621.js"><link rel="prefetch" href="/assets/js/12.6d26de55.js"><link rel="prefetch" href="/assets/js/13.c7f8581d.js"><link rel="prefetch" href="/assets/js/14.7a193a48.js"><link rel="prefetch" href="/assets/js/15.11777617.js"><link rel="prefetch" href="/assets/js/16.dcc84a9b.js"><link rel="prefetch" href="/assets/js/17.ed03640f.js"><link rel="prefetch" href="/assets/js/18.4a809f16.js"><link rel="prefetch" href="/assets/js/19.35e869d5.js"><link rel="prefetch" href="/assets/js/20.0a8ad346.js"><link rel="prefetch" href="/assets/js/21.fbe245ea.js"><link rel="prefetch" href="/assets/js/22.882e2996.js"><link rel="prefetch" href="/assets/js/23.91f3ff60.js"><link rel="prefetch" href="/assets/js/24.a14e4961.js"><link rel="prefetch" href="/assets/js/25.5eb0899f.js"><link rel="prefetch" href="/assets/js/4.d6de8151.js"><link rel="prefetch" href="/assets/js/5.b624c2a6.js"><link rel="prefetch" href="/assets/js/6.88eaa617.js"><link rel="prefetch" href="/assets/js/7.75355971.js"><link rel="prefetch" href="/assets/js/8.c3cbff31.js"><link rel="prefetch" href="/assets/js/9.655a6ab2.js">
    <link rel="stylesheet" href="/assets/css/0.styles.b71a9117.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.jpeg" alt="前端知识体库" class="logo"> <span class="site-name can-hide">前端知识体库</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  每日一鲜
</a></div><div class="nav-item"><a href="/blog.html" class="nav-link">
  学习博客
</a></div><div class="nav-item"><a href="https://juejin.im/timeline" target="_blank" rel="noopener noreferrer" class="nav-link external">
  掘金
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://time.geekbang.org/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  极客时间
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://www.vuepress.cn/guide" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Vuepress
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://github.com/wuzaofeng" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://voice.baidu.com/act/newpneumonia/newpneumonia/?from=osari_pc_3" target="_blank" rel="noopener noreferrer" class="nav-link external">
  疫情实时
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  每日一鲜
</a></div><div class="nav-item"><a href="/blog.html" class="nav-link">
  学习博客
</a></div><div class="nav-item"><a href="https://juejin.im/timeline" target="_blank" rel="noopener noreferrer" class="nav-link external">
  掘金
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://time.geekbang.org/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  极客时间
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://www.vuepress.cn/guide" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Vuepress
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://github.com/wuzaofeng" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://voice.baidu.com/act/newpneumonia/newpneumonia/?from=osari_pc_3" target="_blank" rel="noopener noreferrer" class="nav-link external">
  疫情实时
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/guide/" class="sidebar-link">自动化部署静态文档</a></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>学习笔记</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/learning/html/" class="sidebar-link">html</a></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>CSS</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/learning/css/home-bug/" class="sidebar-link">网厅首页开发问题笔记</a></li><li><a href="/learning/css/select/" class="sidebar-link">CSS选择器笔记</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>javascript</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/learning/javascript/expression.html" class="sidebar-link">什么是表达式语句</a></li><li><a href="/learning/javascript/design/create.html" class="sidebar-link">设计模式(创建设计模式)</a></li><li><a href="/learning/javascript/design/struct.html" class="sidebar-link">设计模式(结构化设计模式)</a></li><li><a href="/learning/javascript/design/behaviour.html" class="sidebar-link">设计模式(行为型设计模式)</a></li><li><a href="/learning/javascript/design/book.html" class="sidebar-link">推荐设计模式书籍</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>typescript</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/learning/typescript/ts-collection-question.html" class="sidebar-link">【好文】耗时一年整理，全网最全的TypeScript踩坑集锦 (纯 TS 问题)</a></li><li><a href="/learning/typescript/ts-collection-config.html" class="sidebar-link">【好文】耗时一年整理，全网最全的TypeScript踩坑集锦 (tsconfig.json 常用配置项注释)</a></li><li><a href="/learning/typescript/ts-collection-react.html" class="sidebar-link">【好文】耗时一年整理，全网最全的TypeScript踩坑集锦（React + TS 项目问题）</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>前端工程化</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/learning/project/webpack.html" class="sidebar-link">【好文】企业级 Webpack 分享总结</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>读书笔记</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/readBook/HighPerformanceJS/" class="sidebar-link">高性能javascript</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>工作笔记</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/working/wechat/webview.html" class="sidebar-link">微信小程序内嵌webview问题</a></li><li><a href="/working/verdaccio.html" class="sidebar-link">verdaccio 指南</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>面试笔记</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/job/jobing1.html" class="sidebar-link">面试题</a></li><li><a href="/job/vue/" class="active sidebar-link">vue面试题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/job/vue/#谈一下你对mvvm原理的理解" class="sidebar-link">谈一下你对MVVM原理的理解</a></li><li class="sidebar-sub-header"><a href="/job/vue/#请说一下响应式数据的原理？" class="sidebar-link">请说一下响应式数据的原理？</a></li><li class="sidebar-sub-header"><a href="/job/vue/#_3-vue中是如何检测数组变化" class="sidebar-link">3.Vue中是如何检测数组变化?</a></li><li class="sidebar-sub-header"><a href="/job/vue/#_4-为何vue采用异步渲染" class="sidebar-link">4.为何Vue采用异步渲染?</a></li><li class="sidebar-sub-header"><a href="/job/vue/#_5-nexttick实现原理" class="sidebar-link">5.nextTick实现原理?</a></li><li class="sidebar-sub-header"><a href="/job/vue/#_6-vue中computed的特点" class="sidebar-link">6. Vue中Computed的特点</a></li><li class="sidebar-sub-header"><a href="/job/vue/#_7-watch中的deep-true-是如何实现的" class="sidebar-link">7.Watch中的deep:true 是如何实现的</a></li><li class="sidebar-sub-header"><a href="/job/vue/#_8-vue组件的生命周期" class="sidebar-link">8.Vue组件的生命周期</a></li><li class="sidebar-sub-header"><a href="/job/vue/#_9-diff算法的时间复杂度" class="sidebar-link">9.diff算法的时间复杂度</a></li><li class="sidebar-sub-header"><a href="/job/vue/#_10-简述vue中diff算法原理" class="sidebar-link">10.简述Vue中diff算法原理</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="vue相关的面试题"><a href="#vue相关的面试题" class="header-anchor">#</a> vue相关的面试题</h1> <h2 id="谈一下你对mvvm原理的理解"><a href="#谈一下你对mvvm原理的理解" class="header-anchor">#</a> 谈一下你对MVVM原理的理解</h2> <p><img src="/assets/img/1.aca24c9e.jpg" alt="1.jpg"></p> <p>说起<code>MVVM</code>, 那么就要说下以前的<code>MVC</code>模式，<code>MVC</code>模式，指的是用户在界面操作时，会请求服务器路由，路由会调用对应的控制器来处理，控制器会拿到数据之后，再返回给前端，页面重新渲染</p> <p>MVVM: 传统的前端会通过操作dom，将数据渲染在页面上， 但MVVM不同， v就是视图，M就是数据，而VM, 就是vue内部帮我们实现了数据渲染操作，通过数据来驱动视图， 当数据有更新变化的时候，vue会自动的通知视图层更新数据（双向数据绑定）</p> <h2 id="请说一下响应式数据的原理？"><a href="#请说一下响应式数据的原理？" class="header-anchor">#</a> 请说一下响应式数据的原理？</h2> <p><img src="/assets/img/2.d7fdca87.jpg" alt="2.jpg"></p> <p>vue是通过<code>Object.defineProperty</code>，数据劫持来实现响应式数据的。当vue初始化数据的时候，会将data里面的数据通过setter, getter, 来劫持数据，
当对应属性，进行依赖收集到当前组件的watcher(渲染类型watcher), 当数据发生变化的时候，会通过watcher通知相关依赖进行更新。</p> <div class="language- extra-class"><pre class="language-text"><code>// core/observer/index  defineReactive方法中
Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      const value = getter ? getter.call(obj) : val
      if (Dep.target) {
        dep.depend() /* 收集依赖 */
        if (childOb) {
          childOb.dep.depend()
          if (Array.isArray(value)) {
            dependArray(value)
          }
        }
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      const value = getter ? getter.call(obj) : val
      if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) {
        return
      }
      if (process.env.NODE_ENV !== 'production' &amp;&amp; customSetter) {
        customSetter()
      }
      if (getter &amp;&amp; !setter) return
      if (setter) {
        setter.call(obj, newVal)
      } else {
        val = newVal
      }
      childOb = !shallow &amp;&amp; observe(newVal)
      dep.notify() /**通知相关依赖进行更新**/
    }
  })
</code></pre></div><h2 id="_3-vue中是如何检测数组变化"><a href="#_3-vue中是如何检测数组变化" class="header-anchor">#</a> 3.Vue中是如何检测数组变化?</h2> <ul><li>Vue是采用函数劫持的方式，来重写数组方法的</li> <li>Vue将data中的数组，<strong>通过原型链来重写</strong>，指向自己自定义的数组原型方法。当调用数组的api时，会调用自己定义的方法，从而检测数组变化</li></ul> <p><img src="/assets/img/3.04a012d5.jpg" alt="3.jpg"></p> <div class="language- extra-class"><pre class="language-text"><code>// core/observer/array
const arrayProto = Array.prototype
export const arrayMethods = Object.create(arrayProto)

const methodsToPatch = [
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
]

/**
 * Intercept mutating methods and emit events
 */
methodsToPatch.forEach(function (method) { // 重写原型方法
  // cache original method
  const original = arrayProto[method] // 调用原数组的方法
  def(arrayMethods, method, function mutator (...args) {
    const result = original.apply(this, args)
    const ob = this.__ob__
    let inserted
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args
        break
      case 'splice':
        inserted = args.slice(2)
        break
    }
    if (inserted) ob.observeArray(inserted)
    // notify change
    ob.dep.notify() // 当调用数组方法后，手动通知视图更新
    return result
  })
})
</code></pre></div><h2 id="_4-为何vue采用异步渲染"><a href="#_4-为何vue采用异步渲染" class="header-anchor">#</a> 4.为何Vue采用异步渲染?</h2> <p>理解：因为如果不采用异步更新，那么每次更新数据都会对当前组件进行<strong>重新渲染</strong>.所以为了<strong>性能考虑</strong>。 Vue
会在本轮数据更新后，再去异步更新视图!</p> <p><img src="/assets/img/4.be83c188.jpg" alt="4.jpg"></p> <div class="language- extra-class"><pre class="language-text"><code>// core/observer/watcher
  update () {
    /* istanbul ignore else */
    if (this.lazy) {
      this.dirty = true
    } else if (this.sync) {
      this.run()
    } else {
      queueWatcher(this)
    }
  }

// core/observer/scheduler
export function queueWatcher (watcher: Watcher) {
  const id = watcher.id
  if (has[id] == null) {
    has[id] = true
    if (!flushing) {
      queue.push(watcher)
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      let i = queue.length - 1
      while (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) {
        i--
      }
      queue.splice(i + 1, 0, watcher)
    }
    // queue the flush
    if (!waiting) {
      waiting = true

      if (process.env.NODE_ENV !== 'production' &amp;&amp; !config.async) {
        flushSchedulerQueue()
        return
      }
      nextTick(flushSchedulerQueue)
    }
  }
}
</code></pre></div><h2 id="_5-nexttick实现原理"><a href="#_5-nexttick实现原理" class="header-anchor">#</a> 5.nextTick实现原理?</h2> <p>nextTick主要采用的是宏任务和微任务，通过定义一个异步方法，当多次调用nextTick的时候，会将回调函数通过数组的形式插入到队列中
<img src="/assets/img/5.5ef7edb9.jpg" alt="5.jpg"></p> <div class="language- extra-class"><pre class="language-text"><code>// core/util/next-ticks
// 定义个异步方法
let timerFunc
if (typeof Promise !== 'undefined' &amp;&amp; isNative(Promise)) {
  const p = Promise.resolve()
  timerFunc = () =&gt; {
    p.then(flushCallbacks)
    if (isIOS) setTimeout(noop)
  }
} else if (!isIE &amp;&amp; typeof MutationObserver !== 'undefined' &amp;&amp; (
  isNative(MutationObserver) ||
  // PhantomJS and iOS 7.x
  MutationObserver.toString() === '[object MutationObserverConstructor]'
)) {
  // Use MutationObserver where native Promise is not available,
  // e.g. PhantomJS, iOS7, Android 4.4
  // (#6466 MutationObserver is unreliable in IE11)
  let counter = 1
  const observer = new MutationObserver(flushCallbacks)
  const textNode = document.createTextNode(String(counter))
  observer.observe(textNode, {
    characterData: true
  })
  timerFunc = () =&gt; {
    counter = (counter + 1) % 2
    textNode.data = String(counter)
  }
} else if (typeof setImmediate !== 'undefined' &amp;&amp; isNative(setImmediate)) {
  // Fallback to setImmediate.
  // Techinically it leverages the (macro) task queue,
  // but it is still a better choice than setTimeout.
  timerFunc = () =&gt; {
    setImmediate(flushCallbacks)
  }
} else {
  // Fallback to setTimeout.
  timerFunc = () =&gt; {
    setTimeout(flushCallbacks, 0)
  }
}

// nextTick实现
export function nextTick (cb?: Function, ctx?: Object) {
  let _resolve
  callbacks.push(() =&gt; {
    if (cb) {
      try {
        cb.call(ctx)
      } catch (e) {
        handleError(e, ctx, 'nextTick')
      }
    } else if (_resolve) {
      _resolve(ctx)
    }
  })
  if (!pending) {
    pending = true
    timerFunc() // 执行异步方法
  }
  // $flow-disable-line
  if (!cb &amp;&amp; typeof Promise !== 'undefined') {
    return new Promise(resolve =&gt; {
      _resolve = resolve
    })
  }
}

</code></pre></div><h2 id="_6-vue中computed的特点"><a href="#_6-vue中computed的特点" class="header-anchor">#</a> 6. Vue中Computed的特点</h2> <p>Computed也是一个watcher，但他具有缓存，只有依赖的属性发生变化的时候，才会更新视图</p> <p><img src="/assets/img/6.a7d37877.jpg" alt="6.jpg"></p> <div class="language- extra-class"><pre class="language-text"><code>// core/instance/state
function initComputed (vm: Component, computed: Object) {
  // $flow-disable-line
  const watchers = vm._computedWatchers = Object.create(null)
  // computed properties are just getters during SSR
  const isSSR = isServerRendering()

  for (const key in computed) {
    const userDef = computed[key]
    const getter = typeof userDef === 'function' ? userDef : userDef.get
    if (process.env.NODE_ENV !== 'production' &amp;&amp; getter == null) {
      warn(
        `Getter is missing for computed property &quot;${key}&quot;.`,
        vm
      )
    }

    if (!isSSR) {
      // create internal watcher for the computed property.
      watchers[key] = new Watcher(
        vm,
        getter || noop,
        noop,
        computedWatcherOptions
      )
    }

    // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.
    if (!(key in vm)) {
      defineComputed(vm, key, userDef)
    } else if (process.env.NODE_ENV !== 'production') {
      if (key in vm.$data) {
        warn(`The computed property &quot;${key}&quot; is already defined in data.`, vm)
      } else if (vm.$options.props &amp;&amp; key in vm.$options.props) {
        warn(`The computed property &quot;${key}&quot; is already defined as a prop.`, vm)
      }
    }
  }
}

function createComputedGetter (key) {
  return function computedGetter () {
    const watcher = this._computedWatchers &amp;&amp; this._computedWatchers[key]
    if (watcher) {
      if (watcher.dirty) { // 如果依赖的值没发生变化,就不会重新求值
        watcher.evaluate()
      }
      if (Dep.target) {
        watcher.depend()
      }
      return watcher.value
    }
  }
}
</code></pre></div><h2 id="_7-watch中的deep-true-是如何实现的"><a href="#_7-watch中的deep-true-是如何实现的" class="header-anchor">#</a> 7.Watch中的deep:true 是如何实现的</h2> <p>当用户指定了 watch 中的deep属性为 true 时，如果当前监控的值是对象类型。会对对象中的每一项进行求值，此时会将当前 watcher 存入到对应属性的依赖中，这样数组中对象发生变化时也会通知数据更新</p> <div class="language- extra-class"><pre class="language-text"><code>core/observer/watcher

get () {
    pushTarget(this)
    let value
    const vm = this.vm
    try {
      value = this.getter.call(vm, vm)
    } catch (e) {
      if (this.user) {
        handleError(e, vm, `getter for watcher &quot;${this.expression}&quot;`)
      } else {
        throw e
      }
    } finally {
      // &quot;touch&quot; every property so they are all tracked as
      // dependencies for deep watching
      if (this.deep) {
        traverse(value)
      }
      popTarget()
      this.cleanupDeps()
    }
    return value
  }

core/observer/traverse

function _traverse (val: any, seen: SimpleSet) {
  let i, keys
  const isA = Array.isArray(val)
  if ((!isA &amp;&amp; !isObject(val)) || Object.isFrozen(val) || val instanceof VNode) {
    return
  }
  if (val.__ob__) {
    const depId = val.__ob__.dep.id
    if (seen.has(depId)) {
      return
    }
    seen.add(depId)
  }
  if (isA) {
    i = val.length
    while (i--) _traverse(val[i], seen)
  } else {
    keys = Object.keys(val)
    i = keys.length
    while (i--) _traverse(val[keys[i]], seen)
  }
}
</code></pre></div><h2 id="_8-vue组件的生命周期"><a href="#_8-vue组件的生命周期" class="header-anchor">#</a> 8.Vue组件的生命周期</h2> <ul><li><code>beforeCreate</code> 在实例初始化之后，数据观测(data observer) 之前被调用</li> <li><code>created</code> 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：</li></ul> <p>数据观测(data observer)，属性和方法的运算， watch/event 事件回调。这里没有$el</p> <ul><li><p><code>beforeMount</code> 在挂载开始之前被调用：相关的 render 函数首次被调用</p></li> <li><p><code>mounted</code>  el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子</p></li> <li><p><code>beforeUpdate</code> 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前</p></li> <li><p><code>updated</code> 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子</p></li> <li><p><code>beforeDestroy</code> 实例销毁之前调用。在这一步，实例仍然完全可用</p></li> <li><p><code>destroyed</code>  实例销毁后调用。调用后， Vue 实例指示的所有东西都会解绑定，所有的事件
监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用</p></li></ul> <p><strong>要掌握每个生命周期内部可以做什么事</strong></p> <ul><li><p><code>created</code> 实例已经创建完成，因为它是最早触发的原因可以进行一些数据，资源的请求</p></li> <li><p><code>mounted</code> 实例已经挂载完成，可以进行一些DOM操作</p></li> <li><p><code>beforeUpdate</code> 可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。</p></li> <li><p><code>updated</code> 可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。 该钩子在服务器端渲染期间不被调用。</p></li> <li><p><code>destroyed</code> 可以执行一些优化操作,清空定时器，解除绑定事件</p></li></ul> <p><img src="/assets/img/5-1.fdfc7a65.jpg" alt="5-1.jpg"> <img src="/assets/img/5-2.cef1389f.jpg" alt="5-2.jpg"> <img src="/assets/img/5-3.c2f4dc7c.jpg" alt="5-3.jpg"></p> <h2 id="_9-diff算法的时间复杂度"><a href="#_9-diff算法的时间复杂度" class="header-anchor">#</a> 9.diff算法的时间复杂度</h2> <p>两个树的完全的 diff 算法是一个时间复杂度为 O(n3) , Vue 进行了优化·O(n3) 复杂度的问题转换成 O(n) 复杂度的问题(只比较同级不考虑跨级问题) 在前端当中， 你很少会跨越层级地移动Dom元素。 所 以 Virtual Dom只会对同一个层级的元素进行对比。</p> <h2 id="_10-简述vue中diff算法原理"><a href="#_10-简述vue中diff算法原理" class="header-anchor">#</a> 10.简述Vue中diff算法原理</h2> <ul><li><p>1.先同级比较，在比较子节点</p></li> <li><p>2.先判断一方有子节点一方没子节点的情况</p></li> <li><p>3.比较都有子节点的情况, 递归比较子节点</p></li></ul> <p><a href="./class.pdf">参考链接</a></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/job/jobing1.html" class="prev">
        面试题
      </a></span> <!----></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.ab23b884.js" defer></script><script src="/assets/js/2.11e16805.js" defer></script><script src="/assets/js/3.4d4ab6c0.js" defer></script>
  </body>
</html>
