(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{210:function(e,t,n){e.exports=n.p+"assets/img/1.aca24c9e.jpg"},211:function(e,t,n){e.exports=n.p+"assets/img/2.d7fdca87.jpg"},212:function(e,t,n){e.exports=n.p+"assets/img/3.04a012d5.jpg"},213:function(e,t,n){e.exports=n.p+"assets/img/4.be83c188.jpg"},214:function(e,t,n){e.exports=n.p+"assets/img/5.5ef7edb9.jpg"},215:function(e,t,n){e.exports=n.p+"assets/img/6.a7d37877.jpg"},216:function(e,t,n){e.exports=n.p+"assets/img/5-1.fdfc7a65.jpg"},217:function(e,t,n){e.exports=n.p+"assets/img/5-2.cef1389f.jpg"},218:function(e,t,n){e.exports=n.p+"assets/img/5-3.c2f4dc7c.jpg"},251:function(e,t,n){"use strict";n.r(t);var r=n(0),a=Object(r.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"vue相关的面试题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vue相关的面试题"}},[e._v("#")]),e._v(" vue相关的面试题")]),e._v(" "),r("h2",{attrs:{id:"_1-谈一下你对mvvm原理的理解"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-谈一下你对mvvm原理的理解"}},[e._v("#")]),e._v(" 1. 谈一下你对MVVM原理的理解")]),e._v(" "),r("p",[r("img",{attrs:{src:n(210),alt:"1.jpg"}})]),e._v(" "),r("p",[e._v("说起"),r("code",[e._v("MVVM")]),e._v(", 那么就要说下以前的"),r("code",[e._v("MVC")]),e._v("模式，"),r("code",[e._v("MVC")]),e._v("模式，指的是用户在界面操作时，会请求服务器路由，路由会调用对应的控制器来处理，控制器会拿到数据之后，再返回给前端，页面重新渲染")]),e._v(" "),r("p",[e._v("MVVM: 传统的前端会通过操作dom，将数据渲染在页面上， 但MVVM不同， v就是视图，M就是数据，而VM, 就是vue内部帮我们实现了数据渲染操作，通过数据来驱动视图， 当数据有更新变化的时候，vue会自动的通知视图层更新数据（双向数据绑定）")]),e._v(" "),r("h2",{attrs:{id:"_2-请说一下响应式数据的原理？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-请说一下响应式数据的原理？"}},[e._v("#")]),e._v(" 2. 请说一下响应式数据的原理？")]),e._v(" "),r("p",[r("img",{attrs:{src:n(211),alt:"2.jpg"}})]),e._v(" "),r("p",[e._v("vue是通过"),r("code",[e._v("Object.defineProperty")]),e._v("，数据劫持来实现响应式数据的。当vue初始化数据的时候，会将data里面的数据通过setter, getter, 来劫持数据，\n当对应属性，进行依赖收集到当前组件的watcher(渲染类型watcher), 当数据发生变化的时候，会通过watcher通知相关依赖进行更新。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// core/observer/index  defineReactive方法中\nObject.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      const value = getter ? getter.call(obj) : val\n      if (Dep.target) {\n        dep.depend() /* 收集依赖 */\n        if (childOb) {\n          childOb.dep.depend()\n          if (Array.isArray(value)) {\n            dependArray(value)\n          }\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      const value = getter ? getter.call(obj) : val\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      if (process.env.NODE_ENV !== 'production' && customSetter) {\n        customSetter()\n      }\n      if (getter && !setter) return\n      if (setter) {\n        setter.call(obj, newVal)\n      } else {\n        val = newVal\n      }\n      childOb = !shallow && observe(newVal)\n      dep.notify() /**通知相关依赖进行更新**/\n    }\n  })\n")])])]),r("h2",{attrs:{id:"_3-vue中是如何检测数组变化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-vue中是如何检测数组变化"}},[e._v("#")]),e._v(" 3.Vue中是如何检测数组变化?")]),e._v(" "),r("ul",[r("li",[e._v("Vue是采用函数劫持的方式，来重写数组方法的")]),e._v(" "),r("li",[e._v("Vue将data中的数组，"),r("strong",[e._v("通过原型链来重写")]),e._v("，指向自己自定义的数组原型方法。当调用数组的api时，会调用自己定义的方法，从而检测数组变化")])]),e._v(" "),r("p",[r("img",{attrs:{src:n(212),alt:"3.jpg"}})]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// core/observer/array\nconst arrayProto = Array.prototype\nexport const arrayMethods = Object.create(arrayProto)\n\nconst methodsToPatch = [\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n]\n\n/**\n * Intercept mutating methods and emit events\n */\nmethodsToPatch.forEach(function (method) { // 重写原型方法\n  // cache original method\n  const original = arrayProto[method] // 调用原数组的方法\n  def(arrayMethods, method, function mutator (...args) {\n    const result = original.apply(this, args)\n    const ob = this.__ob__\n    let inserted\n    switch (method) {\n      case 'push':\n      case 'unshift':\n        inserted = args\n        break\n      case 'splice':\n        inserted = args.slice(2)\n        break\n    }\n    if (inserted) ob.observeArray(inserted)\n    // notify change\n    ob.dep.notify() // 当调用数组方法后，手动通知视图更新\n    return result\n  })\n})\n")])])]),r("h2",{attrs:{id:"_4-为何vue采用异步渲染"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-为何vue采用异步渲染"}},[e._v("#")]),e._v(" 4.为何Vue采用异步渲染?")]),e._v(" "),r("p",[e._v("理解：因为如果不采用异步更新，那么每次更新数据都会对当前组件进行"),r("strong",[e._v("重新渲染")]),e._v(".所以为了"),r("strong",[e._v("性能考虑")]),e._v("。 Vue\n会在本轮数据更新后，再去异步更新视图!")]),e._v(" "),r("p",[r("img",{attrs:{src:n(213),alt:"4.jpg"}})]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// core/observer/watcher\n  update () {\n    /* istanbul ignore else */\n    if (this.lazy) {\n      this.dirty = true\n    } else if (this.sync) {\n      this.run()\n    } else {\n      queueWatcher(this)\n    }\n  }\n\n// core/observer/scheduler\nexport function queueWatcher (watcher: Watcher) {\n  const id = watcher.id\n  if (has[id] == null) {\n    has[id] = true\n    if (!flushing) {\n      queue.push(watcher)\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      let i = queue.length - 1\n      while (i > index && queue[i].id > watcher.id) {\n        i--\n      }\n      queue.splice(i + 1, 0, watcher)\n    }\n    // queue the flush\n    if (!waiting) {\n      waiting = true\n\n      if (process.env.NODE_ENV !== 'production' && !config.async) {\n        flushSchedulerQueue()\n        return\n      }\n      nextTick(flushSchedulerQueue)\n    }\n  }\n}\n")])])]),r("h2",{attrs:{id:"_5-nexttick实现原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-nexttick实现原理"}},[e._v("#")]),e._v(" 5.nextTick实现原理?")]),e._v(" "),r("p",[e._v("nextTick主要采用的是宏任务和微任务，通过定义一个异步方法，当多次调用nextTick的时候，会将回调函数通过数组的形式插入到队列中\n"),r("img",{attrs:{src:n(214),alt:"5.jpg"}})]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// core/util/next-ticks\n// 定义个异步方法\nlet timerFunc\nif (typeof Promise !== 'undefined' && isNative(Promise)) {\n  const p = Promise.resolve()\n  timerFunc = () => {\n    p.then(flushCallbacks)\n    if (isIOS) setTimeout(noop)\n  }\n} else if (!isIE && typeof MutationObserver !== 'undefined' && (\n  isNative(MutationObserver) ||\n  // PhantomJS and iOS 7.x\n  MutationObserver.toString() === '[object MutationObserverConstructor]'\n)) {\n  // Use MutationObserver where native Promise is not available,\n  // e.g. PhantomJS, iOS7, Android 4.4\n  // (#6466 MutationObserver is unreliable in IE11)\n  let counter = 1\n  const observer = new MutationObserver(flushCallbacks)\n  const textNode = document.createTextNode(String(counter))\n  observer.observe(textNode, {\n    characterData: true\n  })\n  timerFunc = () => {\n    counter = (counter + 1) % 2\n    textNode.data = String(counter)\n  }\n} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\n  // Fallback to setImmediate.\n  // Techinically it leverages the (macro) task queue,\n  // but it is still a better choice than setTimeout.\n  timerFunc = () => {\n    setImmediate(flushCallbacks)\n  }\n} else {\n  // Fallback to setTimeout.\n  timerFunc = () => {\n    setTimeout(flushCallbacks, 0)\n  }\n}\n\n// nextTick实现\nexport function nextTick (cb?: Function, ctx?: Object) {\n  let _resolve\n  callbacks.push(() => {\n    if (cb) {\n      try {\n        cb.call(ctx)\n      } catch (e) {\n        handleError(e, ctx, 'nextTick')\n      }\n    } else if (_resolve) {\n      _resolve(ctx)\n    }\n  })\n  if (!pending) {\n    pending = true\n    timerFunc() // 执行异步方法\n  }\n  // $flow-disable-line\n  if (!cb && typeof Promise !== 'undefined') {\n    return new Promise(resolve => {\n      _resolve = resolve\n    })\n  }\n}\n\n")])])]),r("h2",{attrs:{id:"_6-vue中computed的特点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_6-vue中computed的特点"}},[e._v("#")]),e._v(" 6. Vue中Computed的特点")]),e._v(" "),r("p",[e._v("Computed也是一个watcher，但他具有缓存，只有依赖的属性发生变化的时候，才会更新视图")]),e._v(" "),r("p",[r("img",{attrs:{src:n(215),alt:"6.jpg"}})]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// core/instance/state\nfunction initComputed (vm: Component, computed: Object) {\n  // $flow-disable-line\n  const watchers = vm._computedWatchers = Object.create(null)\n  // computed properties are just getters during SSR\n  const isSSR = isServerRendering()\n\n  for (const key in computed) {\n    const userDef = computed[key]\n    const getter = typeof userDef === 'function' ? userDef : userDef.get\n    if (process.env.NODE_ENV !== 'production' && getter == null) {\n      warn(\n        `Getter is missing for computed property \"${key}\".`,\n        vm\n      )\n    }\n\n    if (!isSSR) {\n      // create internal watcher for the computed property.\n      watchers[key] = new Watcher(\n        vm,\n        getter || noop,\n        noop,\n        computedWatcherOptions\n      )\n    }\n\n    // component-defined computed properties are already defined on the\n    // component prototype. We only need to define computed properties defined\n    // at instantiation here.\n    if (!(key in vm)) {\n      defineComputed(vm, key, userDef)\n    } else if (process.env.NODE_ENV !== 'production') {\n      if (key in vm.$data) {\n        warn(`The computed property \"${key}\" is already defined in data.`, vm)\n      } else if (vm.$options.props && key in vm.$options.props) {\n        warn(`The computed property \"${key}\" is already defined as a prop.`, vm)\n      }\n    }\n  }\n}\n\nfunction createComputedGetter (key) {\n  return function computedGetter () {\n    const watcher = this._computedWatchers && this._computedWatchers[key]\n    if (watcher) {\n      if (watcher.dirty) { // 如果依赖的值没发生变化,就不会重新求值\n        watcher.evaluate()\n      }\n      if (Dep.target) {\n        watcher.depend()\n      }\n      return watcher.value\n    }\n  }\n}\n")])])]),r("h2",{attrs:{id:"_7-watch中的deep-true-是如何实现的"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_7-watch中的deep-true-是如何实现的"}},[e._v("#")]),e._v(" 7.Watch中的deep:true 是如何实现的")]),e._v(" "),r("p",[e._v("当用户指定了 watch 中的deep属性为 true 时，如果当前监控的值是对象类型。会对对象中的每一项进行求值，此时会将当前 watcher 存入到对应属性的依赖中，这样数组中对象发生变化时也会通知数据更新")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('core/observer/watcher\n\nget () {\n    pushTarget(this)\n    let value\n    const vm = this.vm\n    try {\n      value = this.getter.call(vm, vm)\n    } catch (e) {\n      if (this.user) {\n        handleError(e, vm, `getter for watcher "${this.expression}"`)\n      } else {\n        throw e\n      }\n    } finally {\n      // "touch" every property so they are all tracked as\n      // dependencies for deep watching\n      if (this.deep) {\n        traverse(value)\n      }\n      popTarget()\n      this.cleanupDeps()\n    }\n    return value\n  }\n\ncore/observer/traverse\n\nfunction _traverse (val: any, seen: SimpleSet) {\n  let i, keys\n  const isA = Array.isArray(val)\n  if ((!isA && !isObject(val)) || Object.isFrozen(val) || val instanceof VNode) {\n    return\n  }\n  if (val.__ob__) {\n    const depId = val.__ob__.dep.id\n    if (seen.has(depId)) {\n      return\n    }\n    seen.add(depId)\n  }\n  if (isA) {\n    i = val.length\n    while (i--) _traverse(val[i], seen)\n  } else {\n    keys = Object.keys(val)\n    i = keys.length\n    while (i--) _traverse(val[keys[i]], seen)\n  }\n}\n')])])]),r("h2",{attrs:{id:"_8-vue组件的生命周期"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_8-vue组件的生命周期"}},[e._v("#")]),e._v(" 8.Vue组件的生命周期")]),e._v(" "),r("ul",[r("li",[r("code",[e._v("beforeCreate")]),e._v(" 在实例初始化之后，数据观测(data observer) 之前被调用")]),e._v(" "),r("li",[r("code",[e._v("created")]),e._v(" 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：")])]),e._v(" "),r("p",[e._v("数据观测(data observer)，属性和方法的运算， watch/event 事件回调。这里没有$el")]),e._v(" "),r("ul",[r("li",[r("p",[r("code",[e._v("beforeMount")]),e._v(" 在挂载开始之前被调用：相关的 render 函数首次被调用")])]),e._v(" "),r("li",[r("p",[r("code",[e._v("mounted")]),e._v("  el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子")])]),e._v(" "),r("li",[r("p",[r("code",[e._v("beforeUpdate")]),e._v(" 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前")])]),e._v(" "),r("li",[r("p",[r("code",[e._v("updated")]),e._v(" 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子")])]),e._v(" "),r("li",[r("p",[r("code",[e._v("beforeDestroy")]),e._v(" 实例销毁之前调用。在这一步，实例仍然完全可用")])]),e._v(" "),r("li",[r("p",[r("code",[e._v("destroyed")]),e._v("  实例销毁后调用。调用后， Vue 实例指示的所有东西都会解绑定，所有的事件\n监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用")])])]),e._v(" "),r("p",[r("strong",[e._v("要掌握每个生命周期内部可以做什么事")])]),e._v(" "),r("ul",[r("li",[r("p",[r("code",[e._v("created")]),e._v(" 实例已经创建完成，因为它是最早触发的原因可以进行一些数据，资源的请求")])]),e._v(" "),r("li",[r("p",[r("code",[e._v("mounted")]),e._v(" 实例已经挂载完成，可以进行一些DOM操作")])]),e._v(" "),r("li",[r("p",[r("code",[e._v("beforeUpdate")]),e._v(" 可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。")])]),e._v(" "),r("li",[r("p",[r("code",[e._v("updated")]),e._v(" 可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。 该钩子在服务器端渲染期间不被调用。")])]),e._v(" "),r("li",[r("p",[r("code",[e._v("destroyed")]),e._v(" 可以执行一些优化操作,清空定时器，解除绑定事件")])])]),e._v(" "),r("p",[r("img",{attrs:{src:n(216),alt:"5-1.jpg"}}),e._v(" "),r("img",{attrs:{src:n(217),alt:"5-2.jpg"}}),e._v(" "),r("img",{attrs:{src:n(218),alt:"5-3.jpg"}})]),e._v(" "),r("h2",{attrs:{id:"_9-v-for与v-if为何不能连用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-v-for与v-if为何不能连用"}},[e._v("#")]),e._v(" 9.v-for与v-if为何不能连用")]),e._v(" "),r("p",[e._v("v-for优先于v-if, 如果连用的话，那么v-for先执行，之后再判断v-if，这样性能这块非常的低\n所以一般用v-if放入外层的template")]),e._v(" "),r("h2",{attrs:{id:"_10-diff算法的时间复杂度"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_10-diff算法的时间复杂度"}},[e._v("#")]),e._v(" 10.diff算法的时间复杂度")]),e._v(" "),r("p",[e._v("两个树的完全的 diff 算法是一个时间复杂度为 O(n3) , Vue 进行了优化·O(n3) 复杂度的问题转换成 O(n) 复杂度的问题(只比较同级不考虑跨级问题) 在前端当中， 你很少会跨越层级地移动Dom元素。 所 以 Virtual Dom只会对同一个层级的元素进行对比。")]),e._v(" "),r("h2",{attrs:{id:"_11-简述vue中diff算法原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_11-简述vue中diff算法原理"}},[e._v("#")]),e._v(" 11.简述Vue中diff算法原理")]),e._v(" "),r("ul",[r("li",[r("p",[e._v("1.先同级比较，在比较子节点")])]),e._v(" "),r("li",[r("p",[e._v("2.先判断一方有子节点一方没子节点的情况")])]),e._v(" "),r("li",[r("p",[e._v("3.比较都有子节点的情况, 递归比较子节点")])])]),e._v(" "),r("p",[r("a",{attrs:{href:"./class.pdf"}},[e._v("参考链接")])])])}),[],!1,null,null,null);t.default=a.exports}}]);