(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{265:function(n,t,e){"use strict";e.r(t);var s=e(0),a=Object(s.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"javascript-继承"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#javascript-继承"}},[n._v("#")]),n._v(" javascript 继承")]),n._v(" "),e("h2",{attrs:{id:"类式继承（原型继承）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类式继承（原型继承）"}},[n._v("#")]),n._v(" 类式继承（原型继承）")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function A () {}\nfunction B () {}\nB.prototype = new A()\n")])])]),e("p",[e("strong",[n._v("优缺点")]),n._v("\n由于指向A的实例， 那么可以访问父类新增原型方法/属性\n但不能多继承")]),n._v(" "),e("h2",{attrs:{id:"构造函数继承"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#构造函数继承"}},[n._v("#")]),n._v(" 构造函数继承")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function A(){}\nfunction B(){\n  A.call(this);\n}\n")])])]),e("p",[e("strong",[n._v("优缺点")]),n._v("\n可以实现多继承\n但不能访问父类原型方法和属性")]),n._v(" "),e("h2",{attrs:{id:"组合式继承"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#组合式继承"}},[n._v("#")]),n._v(" 组合式继承")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function B(){}\nfunction A(){}\nB.prototype = new A();\n\nfunction B(){\n  A.call(this);\n}\n")])])]),e("p",[n._v("可以继承实例属性/方法，也可以继承原型属性/方法，\n但是执行了两个A的构造函数")]),n._v(" "),e("h2",{attrs:{id:"寄生组合式继承"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#寄生组合式继承"}},[n._v("#")]),n._v(" 寄生组合式继承")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("// 寄生组合式继承的核心方法\nfunction inherit(child, parent) {\n    // 继承父类的原型\n    const p = Object.create(parent.prototype)\n    // 重写子类的原型\n    child.prototype = p\n    // 重写被污染的子类的constructor\n    p.constructor = child\n}\n\n// GithubUser, 父类\nfunction GithubUser(username, password) {\n    let _password = password \n    this.username = username \n}\n\nGithubUser.prototype.login = function () {\n    console.log(this.username + '要登录Github，密码是' + _password)\n}\n\n// GithubUser, 子类\nfunction JuejinUser(username, password) {\n    GithubUser.call(this, username, password) // 继承属性\n    this.articles = 3 // 文章数量\n}\n\n// 实现原型上的方法\ninherit(JuejinUser, GithubUser)\n\n// 在原型上添加新方法\nJuejinUser.prototype.readArticle = function () {\n    console.log('Read article')\n}\n\nconst juejinUser1 = new JuejinUser('ulivz', 'xxx')\nconsole.log(juejinUser1)\n\n")])])]),e("p",[e("a",{attrs:{href:"https://juejin.im/post/5a96d78ef265da4e9311b4d8#heading-8",target:"_blank",rel:"noopener noreferrer"}},[n._v("深入JavaScript继承原理"),e("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=a.exports}}]);