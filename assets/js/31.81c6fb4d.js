(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{272:function(n,t,e){"use strict";e.r(t);var o=e(0),s=Object(o.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"【好文】从javascript中看设计模式-总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#【好文】从javascript中看设计模式-总结"}},[n._v("#")]),n._v(" 【好文】从JavaScript中看设计模式(总结)")]),n._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[n._v("概念")]),n._v(" "),e("p",[n._v("设计模式 (Design Pattern) 是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结")])]),n._v(" "),e("p",[n._v("任何事情都有套路，"),e("code",[n._v("设计模式")]),n._v("就是写代码中常见的套路，有些写法我们日常都在使用，下面我们来介绍一下")]),n._v(" "),e("p",[e("strong",[n._v("创建设计模式")]),n._v("：工厂，单例、建造者、原型")]),n._v(" "),e("p",[e("strong",[n._v("结构化设计模式")]),n._v("：外观，适配器，代理，装饰器，享元，桥接，组合")]),n._v(" "),e("p",[e("strong",[n._v("行为型模式")]),n._v("：策略、模板方法、观察者、迭代器、责任链、命令、备忘录、状态、访问者、终结者、解释器")]),n._v(" "),e("h2",{attrs:{id:"代理模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#代理模式"}},[n._v("#")]),n._v(" 代理模式")]),n._v(" "),e("p",[n._v("代理模式的定义：为一个对象提供一个代用品或占位符，以便控制它的访问")]),n._v(" "),e("p",[n._v("常用的虚拟代理形式：某一个花销很大的操作，可以通过"),e("code",[n._v("虚拟代理的方式")]),n._v("延迟这种需要他的时候才去创建（例：使用虚拟代理实现图片懒加载）\n图片懒加载的方式：先通过一张loading图"),e("code",[n._v("占位")]),n._v("，然后通过"),e("code",[n._v("异步的方式加载图片")]),n._v("，等图片加载好了再把请求成功的图片加载到img标签上")]),n._v(" "),e("p",[n._v("栗子:")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("\x3c!-- 插入图片函数 --\x3e\nconst imgFunc = (() => {\n    const imgNode = document.createElement('img')\n    document.body.appendChild(imgNode)\n    return{\n        setSrc: function(src){\n            imgNode.src = src\n        }\n    }\n})()\n\n\x3c!-- 代理函数 --\x3e\nconst proxyImage = (() => {\n  \x3c!-- 创建image对象 --\x3e\n  let img = new Image()\n\n  \x3c!-- 加载完成再插入 --\x3e\n  img.onload = function(){\n    imgFunc.setSrc(this.src)\n  }\n  return {\n    \x3c!-- 加载中插入loading图片 --\x3e\n    setSrc: function(src){\n      imgFunc.setSrc('./loading.gif')\n      img.src = src\n    }\n  }\n})()\nproxyImage.setSrc('./pic.png')()\n\n")])])]),e("p",[n._v("在我们生活中常用的事件代理、"),e("code",[n._v("节流防抖函数")]),n._v("其实都是代理模式的实现")]),n._v(" "),e("h2",{attrs:{id:"装饰器模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#装饰器模式"}},[n._v("#")]),n._v(" 装饰器模式")]),n._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[n._v("介绍")]),n._v(" "),e("p",[n._v("装饰器模式的定义：在"),e("strong",[n._v("不改变")]),n._v("对象自身的基础上，在程序运行期间给对象"),e("strong",[n._v("动态地添加方法")]),n._v("，"),e("strong",[n._v("注解也可以理解为装饰器")]),n._v("。常见应用："),e("strong",[n._v("react的高阶组件")]),n._v("，或者react-redux中的@connect或者自己定义一些高阶组件")])]),n._v(" "),e("p",[n._v("简单实现:")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("import React from 'react'\nconst withLog = Component => {\n  // 完好无损渲染出来, 只是添加了两个生命周期函数\n  class NewComponent extends React.Component{\n    // 1\n    componentWillMount(){ \n      console.time('ComponentRender')\n      console.log('准备完毕了')\n    }\n    render(){  // 完好无损渲染出来\n      return <Component { ...this.props }></Component>\n    }\n    // 2\n    componentDidMount(){\n      console.timeEnd('ComponentRender')\n      console.log('渲染完毕了')\n    }\n  }\n  return NewComponent\n}\nexport { withLog }\n\n@withLog\nclass xxx\n\n")])])]),e("p",[n._v("在redux中可以找出装饰器的方式，其实Vue中的v-input，v-checkbox也可以认为是装饰器模式，对原生input和checkbox做一层装饰")]),n._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[n._v("装饰器模式和代理模式区别")]),n._v(" "),e("p",[n._v("装饰器模式和代理模式的结构看起来非常相似\n这两种模式都描述了怎样为"),e("strong",[n._v("对象提供一定程度上的间接引用")]),n._v("，并且向"),e("strong",[n._v("那个对象发送请求")]),n._v("。")]),n._v(" "),e("p",[n._v("代理模式和装饰器模式最重要的区别在于"),e("strong",[n._v("它们的意图和设计目的")]),n._v("。")]),n._v(" "),e("p",[n._v("代理模式的目的是：当直接"),e("strong",[n._v("访问本体不方便")]),n._v("或者"),e("strong",[n._v("不符合需要")]),n._v("时，为这个本体提供一个替代者。")]),n._v(" "),e("p",[n._v("装饰模式目的是：为对象动态"),e("strong",[n._v("加入的行为")]),n._v("，"),e("strong",[n._v("本体定义了关键功能")]),n._v("，而"),e("strong",[n._v("装饰器提供或拒绝它的访问")]),n._v("，或者"),e("strong",[n._v("在访问本体前做一些额外的事")]),n._v("。")])]),n._v(" "),e("h2",{attrs:{id:"外观模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#外观模式"}},[n._v("#")]),n._v(" 外观模式")]),n._v(" "),e("p",[n._v("**外观模式的定义：**即在内部让多个方法一起被调用")]),n._v(" "),e("p",[n._v("举个简单的栗子")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("// 封装一些事件，让其兼容各个浏览器\nconst myEvent = {\n  stopBubble(e){\n    if(typeof e.preventDefault() === 'function'){\n      e.preventDefault()\n    }\n    if(typeof e.stopPropagation() === 'function'){\n      e.stopPropagation()\n    }\n    // for IE\n    if(typeof e.returnValue === 'boolean'){\n      e.returnValue = false\n    }\n    if(typeof e.cancelBubble === 'boolean'){\n      e.cancelBubble = false\n    }\n  },\n  addEvent(dom, type, cb){\n    if(dom.addEventListener){\n      dom.addEventListener(type, cb, false)\n    } else if(dom.attachEvent){\n      dom.attachEvent('on' + type, cb)\n    }else{\n      dom['on' + type] = cb\n    }\n  }\n}\n")])])]),e("p",[n._v("以上就用外观模式封装了两个基本事件，让其兼容各种浏览器，调用者"),e("strong",[n._v("不需要知道内部的构造")]),n._v("，只要知道"),e("strong",[n._v("这个方法")]),n._v("怎么用就行了\n如jq插件那些，只需要学会用，无需在乎内部的源码")]),n._v(" "),e("h2",{attrs:{id:"享元模式-常用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#享元模式-常用"}},[n._v("#")]),n._v(" 享元模式(常用)")]),n._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[n._v("定义")]),n._v(" "),e("p",[n._v("一种用于性能优化的模式，fly在这里是苍蝇的意思，意为蝇量级。享元模式的核心是"),e("strong",[n._v("运用共享技术")]),n._v("来有效"),e("strong",[n._v("支持大量细粒度")]),n._v("的"),e("strong",[n._v("对象")]),n._v("。如果系统中因为创建了大量类似的对象而导致内存占用过高，享元模式就是非常有用了。在JavaScript中，浏览器特别是"),e("strong",[n._v("移动端的浏览器分配的内存并不多")]),n._v("，如何节省内存就成了一件非常有意义的事情")])]),n._v(" "),e("p",[n._v("假设有个内衣工厂，目前的产品有50中男衣和50中女士内衣，为了推销产品，工厂决定生产一些塑料模特来穿上他们的内衣拍成广告照片。\n正常情况下需要50个男模特和50个女模特，然后让他们每人分别穿上一件内衣来拍照")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("const Model = function(sex, underwear){\n  this.sex = sex\n  this.underwear = underwear\n}\nModel.prototype.takePhoto = function(){\n  console.log('sex=' + this.sex + ' underwear=' + this.underwear)\n}\nfor(let i = 1; i <= 50; i++){\n  let maleModel = new Model('male', 'underwear' + i)\n  maleModel.takePhoto()\n}\nfor(let join = 1; join <= 50; join++){\n  let femaleModel = new Model('female', 'underwear' + join)\n  femaleModel.takePhoto()\n}\n\n")])])]),e("p",[n._v("采用享元模式")]),n._v(" "),e("p",[n._v("其实无需创建多个模特，只需要一个女模特和一个男模特，让她们分别穿上衣服拍照，可以减少创建多成本")]),n._v(" "),e("p",[n._v("拍照，性别都是内部状态，而需要数量多少个，那就是外部状态")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("const Model = function(sex){\n  this.sex = sex\n}\nModel.prototype.takePhoto = function(){\n  console.log('sex=' + this.sex + ' underwear=' + this.underwear)\n}\n// 分别创建一个男模特和一个女模特对象\nlet maleModel = new Model('male'),\n    femaleModel = new Model('female')\n// 给男模特依次穿上所有的男装，并进行拍照\nfor(let i = 1; i <= 50; i++){\n  maleModel.underwear = 'underwear' + i\n  maleModel.takePhoto()\n}\n// 给女模特依次穿上所有的女装，并进行拍照\nfor(let j = 1; j <= 50; j++){\n  femaleModel.underwear = 'underwear' + j\n  femaleModel.takePhoto()\n}\n")])])]),e("ul",[e("li",[e("p",[n._v("内部状态存储于"),e("strong",[n._v("对象内部")])])]),n._v(" "),e("li",[e("p",[n._v("内部状态可以被"),e("strong",[n._v("一些对象共享")])])]),n._v(" "),e("li",[e("p",[n._v("内部状态独立于具体的场景，"),e("strong",[n._v("通常不会改变")])])]),n._v(" "),e("li",[e("p",[n._v("外部状态取决于具体的场景，"),e("strong",[n._v("并根据场景而变化")]),n._v("，外部状态不能被共享")])])]),n._v(" "),e("h2",{attrs:{id:"适配器模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#适配器模式"}},[n._v("#")]),n._v(" 适配器模式")]),n._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[n._v("含义")]),n._v(" "),e("p",[n._v("适配器模式定义："),e("strong",[n._v("解决两个软件实体间的接口不兼容")]),n._v("的问题。")]),n._v(" "),e("p",[n._v("使用适配器模式之后，原本由于接口不兼容而不能工作的两个软件实体可以一起工作。")]),n._v(" "),e("p",[n._v("适配器的别名是包装器（wrapper），这是一个相对简单的模式。")]),n._v(" "),e("p",[n._v("在程序开发过程中有许多这样的"),e("strong",[n._v("场景")]),n._v("：当我们试图调用模块或者对象的某个接口时，却发现这个接口的格式并不符合目前需求。\n这时候有两种解决办法，第一种是修改原来的接口实现，但如果原来的模板很复杂，或者我们拿到模块是一段别人编写的经过压缩的代码，修改原接口就显得不太现实了。")]),n._v(" "),e("p",[n._v("第二种方法是创建一个适配器，将原接口转换为客户希望的另一个接口，客户只需要和适配器打交道")])]),n._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[n._v("参考地址")]),n._v(" "),e("p",[e("a",{attrs:{href:"https://www.cnblogs.com/TomXu/archive/2012/04/11/2435452.html",target:"_blank",rel:"noopener noreferrer"}},[n._v("设计模式之适配器模式"),e("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=s.exports}}]);