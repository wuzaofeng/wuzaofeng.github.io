(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{224:function(t,r,a){t.exports=a.p+"assets/img/proto.5e18c31b.png"},225:function(t,r,a){t.exports=a.p+"assets/img/insertionsort.49798027.gif"},226:function(t,r,a){t.exports=a.p+"assets/img/quicksort.a0a0a922.gif"},269:function(t,r,a){"use strict";a.r(r);var e=a(0),v=Object(e.a)({},(function(){var t=this,r=t.$createElement,e=t._self._c||r;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"原型以及原型链"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原型以及原型链"}},[t._v("#")]),t._v(" 原型以及原型链")]),t._v(" "),e("h3",{attrs:{id:"原型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原型"}},[t._v("#")]),t._v(" 原型")]),t._v(" "),e("p",[t._v("本质是一个js对象(除了"),e("code",[t._v("null")]),t._v(")，当我们通过"),e("strong",[t._v("构造函数")]),t._v("创建"),e("strong",[t._v("实例")]),t._v("的时候，构造函数的其中一个属性"),e("code",[t._v("prototype")]),t._v("指向"),e("strong",[t._v("原型")]),t._v("，"),e("strong",[t._v("实例")]),t._v("的"),e("code",[t._v("_proto_")]),t._v("指向"),e("strong",[t._v("原型")])]),t._v(" "),e("p",[t._v("实例对象与原型对象之间通过"),e("code",[t._v("_proto_")]),t._v("来关联起来，当实例的属性找不到的时候会通过"),e("code",[t._v("_proto")]),t._v("继续往上层原型对象查找，直到找到"),e("code",[t._v("Object.prototype")]),t._v("为止")]),t._v(" "),e("p",[t._v("用于创建出来的实例共享属性以及方法")]),t._v(" "),e("h3",{attrs:{id:"原型链"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原型链"}},[t._v("#")]),t._v(" 原型链")]),t._v(" "),e("p",[e("strong",[t._v("原型链")]),t._v("是通过实例的"),e("code",[t._v("_proto")]),t._v("属性，查找原型对象，如果找不到，会往上查找。这样成为一个原型链，一般是用于继承")]),t._v(" "),e("p",[t._v("关于Function__proto__===Function.prototype的问题")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://github.com/jawil/blog/issues/13",target:"_blank",rel:"noopener noreferrer"}},[t._v("从探究Function."),e("strong",[t._v("proto")]),t._v("===Function.prototype过程中的一些收获"),e("OutboundLink")],1)]),t._v(" "),e("p",[e("img",{attrs:{src:a(224),alt:"原型图"}})]),t._v(" "),e("h2",{attrs:{id:"作用域"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#作用域"}},[t._v("#")]),t._v(" 作用域")]),t._v(" "),e("p",[t._v("js是"),e("strong",[t._v("词法作用域")]),t._v("，也就是"),e("strong",[t._v("静态作用域")])]),t._v(" "),e("p",[e("strong",[t._v("静态作用域")]),t._v("是，函数作用域在**(函数定义)**的时候就决定了 (该作用域是父级创建的所以作用域链)")]),t._v(" "),e("p",[e("strong",[t._v("动态作用域")]),t._v("是，函数作用域在"),e("strong",[t._v("函数调用")]),t._v("的时候才决定的。")]),t._v(" "),e("h3",{attrs:{id:"个人理解作用域"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#个人理解作用域"}},[t._v("#")]),t._v(" 个人理解作用域")]),t._v(" "),e("p",[t._v("作用域有两种")]),t._v(" "),e("p",[t._v("一种是函数创建的时候，会有个"),e("strong",[t._v("静态作用域")]),t._v("，静态作用域是指将父级或父级以上的作用域的所有变量对象，可以理解成一个"),e("strong",[t._v("父级的作用域链")])]),t._v(" "),e("p",[t._v("第二种，就是函数执行的时候，会创建一个执行上下文，也就是会创建一个作用域，是函数独有的作用域，两者加起来就是该函数整体的作用域")]),t._v(" "),e("h2",{attrs:{id:"执行上下文"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#执行上下文"}},[t._v("#")]),t._v(" 执行上下文")]),t._v(" "),e("p",[t._v("js引擎执行代码时会创建执行环境（执行上下文）")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("创建全局函数")])]),t._v(" "),e("li",[e("p",[t._v("函数执行")])]),t._v(" "),e("li",[e("p",[t._v("eval方法调用")])])]),t._v(" "),e("h3",{attrs:{id:"生命周期"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#生命周期"}},[t._v("#")]),t._v(" 生命周期")]),t._v(" "),e("p",[t._v("创建阶段\n在这个阶段中，执行上下文会分别创建变量对象，建立作用域链，以及确定this的指向。")]),t._v(" "),e("p",[t._v("代码执行阶段\n创建完成之后，就会开始执行代码，这个时候，会完成变量赋值，函数引用，以及执行其他代码")]),t._v(" "),e("h3",{attrs:{id:"执行上下文都会包含三个重要属性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#执行上下文都会包含三个重要属性"}},[t._v("#")]),t._v(" "),e("strong",[t._v("执行上下文都会包含三个重要属性")])]),t._v(" "),e("ol",[e("li",[e("p",[t._v("变量对象（variable Object VO）")])]),t._v(" "),e("li",[e("p",[t._v("作用域链（scoped chain）")])]),t._v(" "),e("li",[e("p",[t._v("this")])])]),t._v(" "),e("h4",{attrs:{id:"变量对象-vo"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#变量对象-vo"}},[t._v("#")]),t._v(" 变量对象(VO)")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("函数的所有形参（如果是函数上下文）")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("由"),e("strong",[t._v("名称和对应值")]),t._v("组成的一个变量对象的属性被创建")])]),t._v(" "),e("li",[e("p",[t._v("没有实参，为undefined")])])])]),t._v(" "),e("li",[e("p",[t._v("函数声明")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("由"),e("strong",[t._v("名称和对应值")]),t._v("（函数对象(function-object)）组成一个变量对象的属性被创建")])]),t._v(" "),e("li",[e("p",[t._v("如果变量对象已经存在相同名称的属性，则"),e("strong",[t._v("完全替换")]),t._v("这个属性")])])])]),t._v(" "),e("li",[e("p",[t._v("变量声明")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("由"),e("strong",[t._v("名称和对应值")]),t._v("（undefined）组成一个变量对象的属性被创建；")])]),t._v(" "),e("li",[e("p",[t._v("如果变量名称跟已经声明的形式参数或函数相同，则变量声明"),e("strong",[t._v("不会干扰")]),t._v("已经存在的这类属性")])])])])]),t._v(" "),e("h5",{attrs:{id:"变量对象（vo）与活动对象（ao）区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#变量对象（vo）与活动对象（ao）区别"}},[t._v("#")]),t._v(" 变量对象（VO）与活动对象（AO）区别")]),t._v(" "),e("p",[t._v("当每次执行上下文之前，会保存上下文定义的属性以及函数声明, 该阶段是不可访问")]),t._v(" "),e("p",[t._v("但执行阶段之后，变量对象（VO）会转成 活动对象（AO）,里面的属性可以访问")]),t._v(" "),e("p",[t._v("本质上都是同一个对象，区别在于运行不同的对象周期")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://github.com/mqyqingfeng/Blog/issues/6",target:"_blank",rel:"noopener noreferrer"}},[t._v("JavaScript深入之作用域链 "),e("OutboundLink")],1)]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[t._v("总结")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("全局上下文的"),e("strong",[t._v("变量对象")]),t._v("初始化是全局对象 (window)")])]),t._v(" "),e("li",[e("p",[t._v("函数上下文的"),e("strong",[t._v("变量对象")]),t._v("初始化只包括 Arguments 对象")])]),t._v(" "),e("li",[e("p",[t._v("在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值")])]),t._v(" "),e("li",[e("p",[t._v("在代码执行阶段，会再次修改变量对象的属性值")])])])]),t._v(" "),e("h2",{attrs:{id:"this"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#this"}},[t._v("#")]),t._v(" this")]),t._v(" "),e("h3",{attrs:{id:"从ecmascript规范"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#从ecmascript规范"}},[t._v("#")]),t._v(" 从ECMAScript规范")]),t._v(" "),e("p",[t._v("判断this")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("计算 "),e("code",[t._v("MemberExpression")]),t._v(" 的结果赋值给 "),e("code",[t._v("ref")]),t._v(" "),e("code",[t._v("MemberExpression")]),t._v(" 左边表达式")])]),t._v(" "),e("li",[e("p",[t._v("判断 "),e("code",[t._v("ref")]),t._v(" 是不是一个 "),e("code",[t._v("Reference")]),t._v(" 类型。")])])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("2.1 如果 ref 是 Reference，并且 IsPropertyReference(ref) 是 true, 那么 this 的值为 GetBase(ref)\n\n2.2 如果 ref 是 Reference，并且 base value 值是 Environment Record, 那么this的值为 ImplicitThisValue(ref)\n\n2.3 如果 ref 不是 Reference，那么 this 的值为 undefined\n")])])]),e("p",[t._v("由于不是严格模式，this如果是undefined，会指向全局对象window")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://github.com/mqyqingfeng/Blog/issues/7",target:"_blank",rel:"noopener noreferrer"}},[t._v("JavaScript深入之从ECMAScript规范解读this"),e("OutboundLink")],1)]),t._v(" "),e("h3",{attrs:{id:"常规理解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#常规理解"}},[t._v("#")]),t._v(" 常规理解")]),t._v(" "),e("p",[t._v("this就是最后调用他的函数，")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("直接调用 window （window 绑定）")])]),t._v(" "),e("li",[e("p",[t._v("对象调用指向对象 （隐式绑定）")])]),t._v(" "),e("li",[e("p",[t._v("new 调用指向实例 （new 绑定）")])]),t._v(" "),e("li",[e("p",[t._v("可以通过call， apply, bind改变（显式绑定）")])])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("1. 查看函数在哪被调用。\n2. 左侧有没有对象？如果有，它就是 “this” 的引用。如果没有，继续第 3 步。\n3. 该函数是不是用 “call”、“apply” 或者 “bind” 调用的？如果是，它会显式地指明 “this” 的引用。如果不是，继续第 4 步。\n4. 该函数是不是用 “new” 调用的？如果是，“this” 指向的就是 JavaScript 解释器新创建的对象。如果不是，继续第 5 步。\n5. 是否在“严格模式”下？如果是，“this” 就是 undefined，如果不是，继续第 6 步。\n6. JavaScript 很奇怪，“this” 会指向 “window” 对象。\n")])])]),e("h2",{attrs:{id:"闭包"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#闭包"}},[t._v("#")]),t._v(" 闭包")]),t._v(" "),e("p",[t._v("指那些能够访问自由变量的函数")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("创建它的执行上下文被销毁了，但它仍然存在（比如内部函数从父函数返回过来）")])]),t._v(" "),e("li",[e("p",[t._v("在代码中引用了自由变量")])])]),t._v(" "),e("p",[t._v("因为闭包能访问以及销毁它但执行上下文访问到变量。而这个变量是无法被销毁的，存储在内存中。")]),t._v(" "),e("h2",{attrs:{id:"参数按值传递"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参数按值传递"}},[t._v("#")]),t._v(" 参数按值传递")]),t._v(" "),e("p",[t._v("参数传递都是按值来传递的，但是js中有分"),e("code",[t._v("基本类型和引用类型")]),t._v("，所说的值传递是指栈中的值拷贝")]),t._v(" "),e("p",[t._v("基本类型是存储在栈内存中，但引用类型是将地址存在栈内存中，而数据存在堆内存中")]),t._v(" "),e("h2",{attrs:{id:"javascript-语言在引擎级别的执行过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#javascript-语言在引擎级别的执行过程"}},[t._v("#")]),t._v(" JavaScript 语言在引擎级别的执行过程")]),t._v(" "),e("h3",{attrs:{id:"一、环境的准备"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一、环境的准备"}},[t._v("#")]),t._v(" 一、环境的准备")]),t._v(" "),e("ol",[e("li",[t._v("作用域 Scope")])]),t._v(" "),e("p",[t._v("作用域本身有两个成员，object 和 parent，作用域中包含对象及属性\n作用域主要有两项功能")]),t._v(" "),e("ul",[e("li",[t._v("查找名字")]),t._v(" "),e("li",[t._v("如果没有，查找 parent 上一层")])]),t._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[t._v("环境 Environment")])]),t._v(" "),e("p",[t._v("词法环境规范：环境记录和 outer，环境记录可以映射为作用域中的 object，outer 映射为作用域中的 parent")]),t._v(" "),e("ol",{attrs:{start:"3"}},[e("li",[t._v("属性标识符")])]),t._v(" "),e("p",[t._v("ES5的重要规范是"),e("strong",[t._v("属性描述符和属性标识符规范")]),t._v("， 所有的环境记录对外统一用一个有意义的"),e("code",[t._v("interface")]),t._v(", 即标识符引用 GetIdentifierReference")]),t._v(" "),e("p",[t._v("标识符引用的所用是代替作用域查找名字的功能，统一格式")]),t._v(" "),e("h3",{attrs:{id:"二-可执行上下文-executive-context"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二-可执行上下文-executive-context"}},[t._v("#")]),t._v(" 二. 可执行上下文 Executive Context")]),t._v(" "),e("p",[t._v("执行上下文添加了两个成员，"),e("strong",[t._v("词法环境")]),t._v("和"),e("strong",[t._v("变量环境")])]),t._v(" "),e("p",[t._v("理论上"),e("strong",[t._v("词法环境")]),t._v("和"),e("strong",[t._v("变量环境")]),t._v("只需要有一个就可以查找名字。但 JavaScript 中变量环境解决 "),e("code",[t._v("var")]),t._v(" 声明，词法环境解决一般"),e("strong",[t._v("变量声明")]),t._v("，两种声明在 "),e("code",[t._v("JavaScript")]),t._v(" 中不兼容")]),t._v(" "),e("p",[t._v("1.代码层面如何 run")]),t._v(" "),e("p",[t._v("执行栈（ECS）为空时，会自动去找任务队列中的函数，并且执行，执行栈是先进后出的原则，任务队列是先进先出的原则")]),t._v(" "),e("p",[t._v("一开始，会执行1. 内核引擎所需要执行上下文（newContext for job），之后2. 通过newContext创建"),e("code",[t._v("scriptContext")]),t._v("执行上下文(变量环境和词法环境)")]),t._v(" "),e("p",[t._v("ScriptContext 执行上下文具体还可分为四种可执行的上下文，全局初始化、模块初始化环境、实例化函数环境、实例化 Eval 环境等。")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("执行表达式\n执行表达式返回的结果包括原始值，对象，引用规范类型。")])]),t._v(" "),e("li",[e("p",[t._v("执行语句\n执行语句返回的结果是完整规范类型，表示语句是否被完整执行，是否中断，返\n回值不包含引用。")])])]),t._v(" "),e("h2",{attrs:{id:"继承"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#继承"}},[t._v("#")]),t._v(" 继承")]),t._v(" "),e("p",[t._v("面向对象三大特性\n封装：低耦合高内聚\n多态：重载和重写")]),t._v(" "),e("ul",[e("li",[t._v("重载：方法名相同，形参的个数或者类型不一样（js不存在真正意义上的重载）（可以通过arguments）实现重载")]),t._v(" "),e("li",[t._v("重写：类的继承中，子类可以重写继承父类的方法")])]),t._v(" "),e("h3",{attrs:{id:"原型链继承"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原型链继承"}},[t._v("#")]),t._v(" 原型链继承")]),t._v(" "),e("p",[t._v("原理：child.prototype = new Parent()")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("引用类型的属性会被所有实例共享")])]),t._v(" "),e("li",[e("p",[t._v("在创建实例的时候，不能向父级构造函数传参")])]),t._v(" "),e("li",[e("p",[t._v("不能实现多继承")])])]),t._v(" "),e("h3",{attrs:{id:"构造函数继承"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#构造函数继承"}},[t._v("#")]),t._v(" 构造函数继承")]),t._v(" "),e("p",[t._v("原理：Parent.call(this)")]),t._v(" "),e("p",[e("strong",[t._v("优点")])]),t._v(" "),e("ol",[e("li",[e("p",[t._v("避免引用类型属性被所有实例共享")])]),t._v(" "),e("li",[e("p",[t._v("创建实例的时候可以传入参数")])]),t._v(" "),e("li",[e("p",[t._v("多继承")])])]),t._v(" "),e("p",[e("strong",[t._v("缺点")])]),t._v(" "),e("p",[t._v("方法都定义在构造器中，每次创建实例，会创建一边方法")]),t._v(" "),e("h3",{attrs:{id:"组合-原型链和构造函数-继承"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#组合-原型链和构造函数-继承"}},[t._v("#")]),t._v(" 组合(原型链和构造函数)继承")]),t._v(" "),e("p",[t._v("融合原型链和构造函数都优点")]),t._v(" "),e("p",[t._v("缺点\n调用两次父构造函数")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function Parent (name) {\n    this.name = name;\n    this.colors = ['red', 'blue', 'green'];\n}\n\nParent.prototype.getName = function () {\n    console.log(this.name)\n}\n\nfunction Child (name, age) {\n\n    Parent.call(this, name);\n    this.age = age;\n\n}\n\nChild.prototype = new Parent();\nChild.prototype.constructor = Child;\n\nvar child1 = new Child('kevin', '18');\n\nchild1.colors.push('black');\n\nconsole.log(child1.name); // kevin\nconsole.log(child1.age); // 18\nconsole.log(child1.colors); // [\"red\", \"blue\", \"green\", \"black\"]\n\nvar child2 = new Child('daisy', '20');\n\nconsole.log(child2.name); // daisy\nconsole.log(child2.age); // 20\nconsole.log(child2.colors); // [\"red\", \"blue\", \"green\"]\n")])])]),e("h3",{attrs:{id:"原型式继承"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原型式继承"}},[t._v("#")]),t._v(" 原型式继承")]),t._v(" "),e("p",[t._v("缺点 引用类型属性共享在实例中，和原型链继承一样")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("Object.create\nfunction createObj(o) {\n    function F(){}\n    F.prototype = o;\n    return new F();\n}\n")])])]),e("h3",{attrs:{id:"寄生式继承"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#寄生式继承"}},[t._v("#")]),t._v(" 寄生式继承")]),t._v(" "),e("p",[t._v("缺点 跟借用构造函数模式一样，每次创建对象都会创建一遍方法")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function createObj (o) {\n    var clone = Object.create(o);\n    clone.sayName = function () {\n        console.log('hi');\n    }\n    return clone;\n}\n")])])]),e("h3",{attrs:{id:"寄生组合式继承"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#寄生组合式继承"}},[t._v("#")]),t._v(" 寄生组合式继承")]),t._v(" "),e("p",[t._v("它只调用了一次 Parent 构造函数")]),t._v(" "),e("h2",{attrs:{id:"乱序"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#乱序"}},[t._v("#")]),t._v(" 乱序")]),t._v(" "),e("p",[t._v("遍历元素，获取元素，再将剩余的个数随机获取。互换元素")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function shuffle(a) {\n    var j, x, i;\n    for (i = a.length; i; i--) {\n        j = Math.floor(Math.random() * i);\n        x = a[i - 1];\n        a[i - 1] = a[j];\n        a[j] = x;\n    }\n    return a;\n}\n\nfunction shuffle (arr) {\n  for (var i = 0; i<arr.length; i++) {\n    var j = Math.floor(Math.random() * arr.length)\n\n    var x\n    x = arr[i]\n    arr[i] = arr[j]\n    arr[j] = x\n  }\n  return arr\n}\n")])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function shuffle(a) {\n    for (let i = a.length; i; i--) {\n        let j = Math.floor(Math.random() * i);\n        [a[i - 1], a[j]] = [a[j], a[i - 1]];\n    }\n    return a;\n}\n\nfunction shuffle (arr) {\n   for (let i = 0; i<arr.length; i++) {\n    var j = Math.floor(Math.random() * arr.length)\n    [arr[i], arr[j]] = [arr[j], arr[i]]\n  }\n}\n")])])]),e("h2",{attrs:{id:"插入排序"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#插入排序"}},[t._v("#")]),t._v(" 插入排序")]),t._v(" "),e("p",[t._v("将第一个元素作为有序序列，遍历后面未排序的元素，一个个与已经排序的元素做比较，并且排到前面")]),t._v(" "),e("p",[e("img",{attrs:{src:a(225),alt:"插入排序"}})]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function insertionSort(arr) {\n    for (var i = 1; i < arr.length; i++) {\n        var element = arr[i];\n        for (var j = i - 1; j >= 0; j--) {\n            var tmp = arr[j];\n            var order = tmp - element;\n            if (order > 0) {\n                arr[j + 1] = tmp;\n            } else {\n                break;\n            }\n        }\n        arr[j + 1] = element;\n    }\n    return arr;\n}\n\nvar arr = [6, 5, 4, 3, 2, 1];\nconsole.log(insertionSort(arr));\n")])])]),e("p",[e("a",{attrs:{href:"https://visualgo.net/zh/sorting",target:"_blank",rel:"noopener noreferrer"}},[t._v("插入排序"),e("OutboundLink")],1)]),t._v(" "),e("h2",{attrs:{id:"快速排序"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#快速排序"}},[t._v("#")]),t._v(" 快速排序")]),t._v(" "),e("ol",[e("li",[t._v('选择一个元素作为"基准"')]),t._v(" "),e("li",[t._v('小于"基准"的元素，都移到"基准"的左边；大于"基准"的元素，都移到"基准"的右边。')]),t._v(" "),e("li",[t._v('对"基准"左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。')])]),t._v(" "),e("p",[e("img",{attrs:{src:a(226),alt:"快速排序"}})]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var quickSort = function(arr) {\n　　if (arr.length <= 1) { return arr; }\n    // 取数组的中间元素作为基准\n　　var pivotIndex = Math.floor(arr.length / 2);\n　　var pivot = arr.splice(pivotIndex, 1)[0];\n\n　　var left = [];\n　　var right = [];\n\n　　for (var i = 0; i < arr.length; i++){\n　　　　if (arr[i] < pivot) {\n　　　　　　left.push(arr[i]);\n　　　　} else {\n　　　　　　right.push(arr[i]);\n　　　　}\n　　}\n　　return quickSort(left).concat([pivot], quickSort(right));\n};\n")])])]),e("p",[e("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2011/04/quicksort_in_javascript.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("《快速排序（Quicksort）的Javascript实现》"),e("OutboundLink")],1)])])}),[],!1,null,null,null);r.default=v.exports}}]);