(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{214:function(e,t,n){e.exports=n.p+"assets/img/1.aca24c9e.jpg"},215:function(e,t,n){e.exports=n.p+"assets/img/2.d7fdca87.jpg"},216:function(e,t,n){e.exports=n.p+"assets/img/3.04a012d5.jpg"},217:function(e,t,n){e.exports=n.p+"assets/img/4.be83c188.jpg"},218:function(e,t,n){e.exports=n.p+"assets/img/5.5ef7edb9.jpg"},219:function(e,t,n){e.exports=n.p+"assets/img/6.a7d37877.jpg"},220:function(e,t,n){e.exports=n.p+"assets/img/5-1.fdfc7a65.jpg"},221:function(e,t,n){e.exports=n.p+"assets/img/5-2.cef1389f.jpg"},222:function(e,t,n){e.exports=n.p+"assets/img/5-3.c2f4dc7c.jpg"},223:function(e,t,n){e.exports=n.p+"assets/img/12.2da99ff5.jpg"},224:function(e,t,n){e.exports=n.p+"assets/img/13.cbcb5019.jpg"},271:function(e,t,n){"use strict";n.r(t);var a=n(0),r=Object(a.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"vue相关的面试题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue相关的面试题"}},[e._v("#")]),e._v(" vue相关的面试题")]),e._v(" "),a("h2",{attrs:{id:"_1-谈一下你对mvvm原理的理解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-谈一下你对mvvm原理的理解"}},[e._v("#")]),e._v(" 1. 谈一下你对MVVM原理的理解")]),e._v(" "),a("p",[a("img",{attrs:{src:n(214),alt:"1.jpg"}})]),e._v(" "),a("p",[e._v("说起"),a("code",[e._v("MVVM")]),e._v(", 那么就要说下以前的"),a("code",[e._v("MVC")]),e._v("模式，"),a("code",[e._v("MVC")]),e._v("模式，指的是用户在界面操作时，会请求服务器路由，路由会调用对应的控制器来处理，控制器会拿到数据之后，再返回给前端，页面重新渲染")]),e._v(" "),a("p",[e._v("MVVM: 传统的前端会通过操作dom，将数据渲染在页面上， 但MVVM不同， v就是视图，M就是数据，而VM, 就是vue内部帮我们实现了数据渲染操作，通过数据来驱动视图， 当数据有更新变化的时候，vue会自动的通知视图层更新数据（双向数据绑定）")]),e._v(" "),a("h2",{attrs:{id:"_2-请说一下响应式数据的原理？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-请说一下响应式数据的原理？"}},[e._v("#")]),e._v(" 2. 请说一下响应式数据的原理？")]),e._v(" "),a("p",[a("img",{attrs:{src:n(215),alt:"2.jpg"}})]),e._v(" "),a("p",[e._v("vue是通过"),a("code",[e._v("Object.defineProperty")]),e._v("，数据劫持来实现响应式数据的。当vue初始化数据的时候，会将data里面的数据通过setter, getter, 来劫持数据，\n当对应属性，进行依赖收集到当前组件的watcher(渲染类型watcher), 当数据发生变化的时候，会通过watcher通知相关依赖进行更新。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// core/observer/index  defineReactive方法中\nObject.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      const value = getter ? getter.call(obj) : val\n      if (Dep.target) {\n        dep.depend() /* 收集依赖 */\n        if (childOb) {\n          childOb.dep.depend()\n          if (Array.isArray(value)) {\n            dependArray(value)\n          }\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      const value = getter ? getter.call(obj) : val\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      if (process.env.NODE_ENV !== 'production' && customSetter) {\n        customSetter()\n      }\n      if (getter && !setter) return\n      if (setter) {\n        setter.call(obj, newVal)\n      } else {\n        val = newVal\n      }\n      childOb = !shallow && observe(newVal)\n      dep.notify() /**通知相关依赖进行更新**/\n    }\n  })\n")])])]),a("h2",{attrs:{id:"_3-vue中是如何检测数组变化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-vue中是如何检测数组变化"}},[e._v("#")]),e._v(" 3.Vue中是如何检测数组变化?")]),e._v(" "),a("ul",[a("li",[e._v("Vue是采用函数劫持的方式，来重写数组方法的")]),e._v(" "),a("li",[e._v("Vue将data中的数组，"),a("strong",[e._v("通过原型链来重写")]),e._v("，指向自己自定义的数组原型方法。当调用数组的api时，会调用自己定义的方法，从而检测数组变化")])]),e._v(" "),a("p",[a("img",{attrs:{src:n(216),alt:"3.jpg"}})]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// core/observer/array\nconst arrayProto = Array.prototype\nexport const arrayMethods = Object.create(arrayProto)\n\nconst methodsToPatch = [\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n]\n\n/**\n * Intercept mutating methods and emit events\n */\nmethodsToPatch.forEach(function (method) { // 重写原型方法\n  // cache original method\n  const original = arrayProto[method] // 调用原数组的方法\n  def(arrayMethods, method, function mutator (...args) {\n    const result = original.apply(this, args)\n    const ob = this.__ob__\n    let inserted\n    switch (method) {\n      case 'push':\n      case 'unshift':\n        inserted = args\n        break\n      case 'splice':\n        inserted = args.slice(2)\n        break\n    }\n    if (inserted) ob.observeArray(inserted)\n    // notify change\n    ob.dep.notify() // 当调用数组方法后，手动通知视图更新\n    return result\n  })\n})\n")])])]),a("h2",{attrs:{id:"_4-为何vue采用异步渲染"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-为何vue采用异步渲染"}},[e._v("#")]),e._v(" 4.为何Vue采用异步渲染?")]),e._v(" "),a("p",[e._v("理解：因为如果不采用异步更新，那么每次更新数据都会对当前组件进行"),a("strong",[e._v("重新渲染")]),e._v(".所以为了"),a("strong",[e._v("性能考虑")]),e._v("。 Vue\n会在本轮数据更新后，再去异步更新视图!")]),e._v(" "),a("p",[a("img",{attrs:{src:n(217),alt:"4.jpg"}})]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// core/observer/watcher\n  update () {\n    /* istanbul ignore else */\n    if (this.lazy) {\n      this.dirty = true\n    } else if (this.sync) {\n      this.run()\n    } else {\n      queueWatcher(this)\n    }\n  }\n\n// core/observer/scheduler\nexport function queueWatcher (watcher: Watcher) {\n  const id = watcher.id\n  if (has[id] == null) {\n    has[id] = true\n    if (!flushing) {\n      queue.push(watcher)\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      let i = queue.length - 1\n      while (i > index && queue[i].id > watcher.id) {\n        i--\n      }\n      queue.splice(i + 1, 0, watcher)\n    }\n    // queue the flush\n    if (!waiting) {\n      waiting = true\n\n      if (process.env.NODE_ENV !== 'production' && !config.async) {\n        flushSchedulerQueue()\n        return\n      }\n      nextTick(flushSchedulerQueue)\n    }\n  }\n}\n")])])]),a("h2",{attrs:{id:"_5-nexttick实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-nexttick实现原理"}},[e._v("#")]),e._v(" 5.nextTick实现原理?")]),e._v(" "),a("p",[e._v("nextTick主要采用的是宏任务和微任务，通过定义一个异步方法，当多次调用nextTick的时候，会将回调函数通过数组的形式插入到队列中\n"),a("img",{attrs:{src:n(218),alt:"5.jpg"}})]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// core/util/next-ticks\n// 定义个异步方法\nlet timerFunc\nif (typeof Promise !== 'undefined' && isNative(Promise)) {\n  const p = Promise.resolve()\n  timerFunc = () => {\n    p.then(flushCallbacks)\n    if (isIOS) setTimeout(noop)\n  }\n} else if (!isIE && typeof MutationObserver !== 'undefined' && (\n  isNative(MutationObserver) ||\n  // PhantomJS and iOS 7.x\n  MutationObserver.toString() === '[object MutationObserverConstructor]'\n)) {\n  // Use MutationObserver where native Promise is not available,\n  // e.g. PhantomJS, iOS7, Android 4.4\n  // (#6466 MutationObserver is unreliable in IE11)\n  let counter = 1\n  const observer = new MutationObserver(flushCallbacks)\n  const textNode = document.createTextNode(String(counter))\n  observer.observe(textNode, {\n    characterData: true\n  })\n  timerFunc = () => {\n    counter = (counter + 1) % 2\n    textNode.data = String(counter)\n  }\n} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\n  // Fallback to setImmediate.\n  // Techinically it leverages the (macro) task queue,\n  // but it is still a better choice than setTimeout.\n  timerFunc = () => {\n    setImmediate(flushCallbacks)\n  }\n} else {\n  // Fallback to setTimeout.\n  timerFunc = () => {\n    setTimeout(flushCallbacks, 0)\n  }\n}\n\n// nextTick实现\nexport function nextTick (cb?: Function, ctx?: Object) {\n  let _resolve\n  callbacks.push(() => {\n    if (cb) {\n      try {\n        cb.call(ctx)\n      } catch (e) {\n        handleError(e, ctx, 'nextTick')\n      }\n    } else if (_resolve) {\n      _resolve(ctx)\n    }\n  })\n  if (!pending) {\n    pending = true\n    timerFunc() // 执行异步方法\n  }\n  // $flow-disable-line\n  if (!cb && typeof Promise !== 'undefined') {\n    return new Promise(resolve => {\n      _resolve = resolve\n    })\n  }\n}\n\n")])])]),a("h2",{attrs:{id:"_6-vue中computed的特点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-vue中computed的特点"}},[e._v("#")]),e._v(" 6. Vue中Computed的特点")]),e._v(" "),a("p",[e._v("Computed也是一个watcher，但他具有缓存，只有依赖的属性发生变化的时候，才会更新视图")]),e._v(" "),a("p",[a("img",{attrs:{src:n(219),alt:"6.jpg"}})]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// core/instance/state\nfunction initComputed (vm: Component, computed: Object) {\n  // $flow-disable-line\n  const watchers = vm._computedWatchers = Object.create(null)\n  // computed properties are just getters during SSR\n  const isSSR = isServerRendering()\n\n  for (const key in computed) {\n    const userDef = computed[key]\n    const getter = typeof userDef === 'function' ? userDef : userDef.get\n    if (process.env.NODE_ENV !== 'production' && getter == null) {\n      warn(\n        `Getter is missing for computed property \"${key}\".`,\n        vm\n      )\n    }\n\n    if (!isSSR) {\n      // create internal watcher for the computed property.\n      watchers[key] = new Watcher(\n        vm,\n        getter || noop,\n        noop,\n        computedWatcherOptions\n      )\n    }\n\n    // component-defined computed properties are already defined on the\n    // component prototype. We only need to define computed properties defined\n    // at instantiation here.\n    if (!(key in vm)) {\n      defineComputed(vm, key, userDef)\n    } else if (process.env.NODE_ENV !== 'production') {\n      if (key in vm.$data) {\n        warn(`The computed property \"${key}\" is already defined in data.`, vm)\n      } else if (vm.$options.props && key in vm.$options.props) {\n        warn(`The computed property \"${key}\" is already defined as a prop.`, vm)\n      }\n    }\n  }\n}\n\nfunction createComputedGetter (key) {\n  return function computedGetter () {\n    const watcher = this._computedWatchers && this._computedWatchers[key]\n    if (watcher) {\n      if (watcher.dirty) { // 如果依赖的值没发生变化,就不会重新求值\n        watcher.evaluate()\n      }\n      if (Dep.target) {\n        watcher.depend()\n      }\n      return watcher.value\n    }\n  }\n}\n")])])]),a("h2",{attrs:{id:"_7-watch中的deep-true-是如何实现的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-watch中的deep-true-是如何实现的"}},[e._v("#")]),e._v(" 7.Watch中的deep:true 是如何实现的")]),e._v(" "),a("p",[e._v("当用户指定了 watch 中的deep属性为 true 时，如果当前监控的值是对象类型。会对对象中的每一项进行求值，此时会将当前 watcher 存入到对应属性的依赖中，这样数组中对象发生变化时也会通知数据更新")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('core/observer/watcher\n\nget () {\n    pushTarget(this)\n    let value\n    const vm = this.vm\n    try {\n      value = this.getter.call(vm, vm)\n    } catch (e) {\n      if (this.user) {\n        handleError(e, vm, `getter for watcher "${this.expression}"`)\n      } else {\n        throw e\n      }\n    } finally {\n      // "touch" every property so they are all tracked as\n      // dependencies for deep watching\n      if (this.deep) {\n        traverse(value)\n      }\n      popTarget()\n      this.cleanupDeps()\n    }\n    return value\n  }\n\ncore/observer/traverse\n\nfunction _traverse (val: any, seen: SimpleSet) {\n  let i, keys\n  const isA = Array.isArray(val)\n  if ((!isA && !isObject(val)) || Object.isFrozen(val) || val instanceof VNode) {\n    return\n  }\n  if (val.__ob__) {\n    const depId = val.__ob__.dep.id\n    if (seen.has(depId)) {\n      return\n    }\n    seen.add(depId)\n  }\n  if (isA) {\n    i = val.length\n    while (i--) _traverse(val[i], seen)\n  } else {\n    keys = Object.keys(val)\n    i = keys.length\n    while (i--) _traverse(val[keys[i]], seen)\n  }\n}\n')])])]),a("h2",{attrs:{id:"_8-vue组件的生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-vue组件的生命周期"}},[e._v("#")]),e._v(" 8.Vue组件的生命周期")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("beforeCreate")]),e._v(" 在实例初始化之后，数据观测(data observer) 之前被调用")]),e._v(" "),a("li",[a("code",[e._v("created")]),e._v(" 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：")])]),e._v(" "),a("p",[e._v("数据观测(data observer)，属性和方法的运算， watch/event 事件回调。这里没有$el")]),e._v(" "),a("ul",[a("li",[a("p",[a("code",[e._v("beforeMount")]),e._v(" 在挂载开始之前被调用：相关的 render 函数首次被调用")])]),e._v(" "),a("li",[a("p",[a("code",[e._v("mounted")]),e._v("  el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子")])]),e._v(" "),a("li",[a("p",[a("code",[e._v("beforeUpdate")]),e._v(" 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前")])]),e._v(" "),a("li",[a("p",[a("code",[e._v("updated")]),e._v(" 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子")])]),e._v(" "),a("li",[a("p",[a("code",[e._v("beforeDestroy")]),e._v(" 实例销毁之前调用。在这一步，实例仍然完全可用")])]),e._v(" "),a("li",[a("p",[a("code",[e._v("destroyed")]),e._v("  实例销毁后调用。调用后， Vue 实例指示的所有东西都会解绑定，所有的事件\n监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用")])])]),e._v(" "),a("p",[a("strong",[e._v("要掌握每个生命周期内部可以做什么事")])]),e._v(" "),a("ul",[a("li",[a("p",[a("code",[e._v("created")]),e._v(" 实例已经创建完成，因为它是最早触发的原因可以进行一些数据，资源的请求")])]),e._v(" "),a("li",[a("p",[a("code",[e._v("mounted")]),e._v(" 实例已经挂载完成，可以进行一些DOM操作")])]),e._v(" "),a("li",[a("p",[a("code",[e._v("beforeUpdate")]),e._v(" 可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。")])]),e._v(" "),a("li",[a("p",[a("code",[e._v("updated")]),e._v(" 可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。 该钩子在服务器端渲染期间不被调用。")])]),e._v(" "),a("li",[a("p",[a("code",[e._v("destroyed")]),e._v(" 可以执行一些优化操作,清空定时器，解除绑定事件")])])]),e._v(" "),a("p",[a("img",{attrs:{src:n(220),alt:"5-1.jpg"}}),e._v(" "),a("img",{attrs:{src:n(221),alt:"5-2.jpg"}}),e._v(" "),a("img",{attrs:{src:n(222),alt:"5-3.jpg"}})]),e._v(" "),a("h2",{attrs:{id:"_9-v-for与v-if为何不能连用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-v-for与v-if为何不能连用"}},[e._v("#")]),e._v(" 9.v-for与v-if为何不能连用")]),e._v(" "),a("p",[e._v("v-for优先于v-if, 如果连用的话，那么v-for先执行，之后再判断v-if，这样性能这块非常的低\n所以一般用v-if放入外层的template")]),e._v(" "),a("h2",{attrs:{id:"_10-diff算法的时间复杂度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10-diff算法的时间复杂度"}},[e._v("#")]),e._v(" 10.diff算法的时间复杂度")]),e._v(" "),a("p",[e._v("两个树的完全的 diff 算法是一个时间复杂度为 O(n3) , Vue 进行了优化·O(n3) 复杂度的问题转换成 O(n) 复杂度的问题(只比较同级不考虑跨级问题) 在前端当中， 你很少会跨越层级地移动Dom元素。 所 以 Virtual Dom只会对同一个层级的元素进行对比。")]),e._v(" "),a("h2",{attrs:{id:"_11-简述vue中diff算法原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_11-简述vue中diff算法原理"}},[e._v("#")]),e._v(" 11.简述Vue中diff算法原理")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("1.先同级比较，在比较子节点")])]),e._v(" "),a("li",[a("p",[e._v("2.先判断一方有子节点一方没子节点的情况")])]),e._v(" "),a("li",[a("p",[e._v("3.比较都有子节点的情况, 递归比较子节点")])])]),e._v(" "),a("h2",{attrs:{id:"_12-v-for中为什么要使用key"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12-v-for中为什么要使用key"}},[e._v("#")]),e._v(" 12.v-for中为什么要使用key")]),e._v(" "),a("p",[e._v("key是"),a("strong",[e._v("需要唯一标识")]),e._v("，而且是"),a("strong",[e._v("不可变的")]),e._v("，防止后续修改删除列表的时候造成bug\nvue对通过diff算法，"),a("strong",[e._v("复用原则")]),e._v("，判断两个dom节点是否一样，如果一样的话会复用原来的dom节点\nkey不能是index，不然也会有同样问题。")]),e._v(" "),a("p",[e._v("如果"),a("strong",[e._v("静态列表的话，就没有删除修改操作")]),e._v("，也就index是唯一标识，就不会有问题")]),e._v(" "),a("p",[a("img",{attrs:{src:n(223),alt:"12.jpg"}})]),e._v(" "),a("p",[a("a",{attrs:{href:"./class.pdf"}},[e._v("参考链接")])]),e._v(" "),a("h2",{attrs:{id:"_13-描述组件渲染和更新过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_13-描述组件渲染和更新过程"}},[e._v("#")]),e._v(" 13. 描述组件渲染和更新过程")]),e._v(" "),a("p",[e._v("组件渲染的时候，通过"),a("strong",[e._v("render函数")]),e._v("生成虚拟节点，再调用"),a("code",[e._v("vue.extends")]),e._v("方法来"),a("strong",[e._v("构建子组件的构造函数")]),e._v("，并且实例化，最后调用"),a("code",[e._v("$mount()")]),e._v("方法挂载在页面上。\n更新的时候，使用的是diff算法比对节点")]),e._v(" "),a("p",[a("img",{attrs:{src:n(224),alt:"13.jpg"}})]),e._v(" "),a("h2",{attrs:{id:"_14-组件中的-data为什么是一个函数-，为什么new-vue的data可以放对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_14-组件中的-data为什么是一个函数-，为什么new-vue的data可以放对象"}},[e._v("#")]),e._v(" 14. 组件中的 data为什么是一个函数?，为什么new Vue的data可以放对象")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("避免同一组件，创建多次实例，而实例使用的同一个构造函数，实例的数据互相影响，保持数据的独立性")])]),e._v(" "),a("li",[a("p",[e._v("什么时候用new Vue，这个是在main.js，根组件实例的时候就一样，我们写项目的时候就只有一个实例")])])]),e._v(" "),a("h2",{attrs:{id:"_15-vue中事件绑定的原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_15-vue中事件绑定的原理"}},[e._v("#")]),e._v(" 15.vue中事件绑定的原理")]),e._v(" "),a("ol",[a("li",[e._v("原生dom的事件绑定， 原生事件")]),e._v(" "),a("li",[e._v("组件的自定义事件")])]),e._v(" "),a("h2",{attrs:{id:"_16-v-model中的实现原理及如何自定义v-model"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_16-v-model中的实现原理及如何自定义v-model"}},[e._v("#")]),e._v(" 16.v-model中的实现原理及如何自定义v-model")]),e._v(" "),a("ol",[a("li",[e._v("原生的 v-model ，会根据标签的不同生成不同的事件和属性")]),e._v(" "),a("li",[e._v("组件的v-model 就是value+input的语法糖")])]),e._v(" "),a("p",[e._v("自定义v-model")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Vue.component('el-checkbox',{\n  template:`<input type=\"checkbox\" :checked=\"check\"\n  @change=\"$emit('change',$event.target.checked)\">`,\n  model:{\n    prop:'check', // 更改默认的value的名字\n    event:'change' // 更改默认的input方法名\n  },\n  props: { check: Boolean }\n})\n")])])]),a("h2",{attrs:{id:"_17-vue中v-html会导致哪些问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_17-vue中v-html会导致哪些问题"}},[e._v("#")]),e._v(" 17.Vue中v-html会导致哪些问题")]),e._v(" "),a("ol",[a("li",[e._v("可能会导致 xss 攻击")]),e._v(" "),a("li",[e._v("v-html 会替换掉标签内部的子元素")]),e._v(" "),a("li",[e._v("样式需要通过deep来添加scoped")])]),e._v(" "),a("h2",{attrs:{id:"_18-vue父子组件生命周期调用顺序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_18-vue父子组件生命周期调用顺序"}},[e._v("#")]),e._v(" 18.Vue父子组件生命周期调用顺序")]),e._v(" "),a("p",[e._v("组件的调用顺序都是先父后子,渲染完成的顺序肯定是先子后父")]),e._v(" "),a("p",[e._v("组件的销毁时是先父后子，销毁完成的顺序是先子后父")]),e._v(" "),a("p",[a("strong",[e._v("加载渲染过程")])]),e._v(" "),a("p",[e._v("父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount- >子mounted->父mounted")]),e._v(" "),a("p",[a("strong",[e._v("子组件更新过程")])]),e._v(" "),a("p",[e._v("父beforeUpdate->子beforeUpdate->子updated->父updated")]),e._v(" "),a("p",[a("strong",[e._v("父组件更新过程")])]),e._v(" "),a("p",[e._v("父beforeUpdate->父updated")]),e._v(" "),a("p",[a("strong",[e._v("销毁过程")])]),e._v(" "),a("p",[e._v("父beforeDestroy->子beforeDestroy->子destroyed->父destroyed")]),e._v(" "),a("h2",{attrs:{id:"_19-vue组件如何通信-单向数据流"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_19-vue组件如何通信-单向数据流"}},[e._v("#")]),e._v(" 19.Vue组件如何通信? 单向数据流")]),e._v(" "),a("ul",[a("li",[e._v("父子间通信 父->子通过 "),a("code",[e._v("props")]),e._v(" 、子-> 父 "),a("code",[e._v("$on、$emit")]),e._v(" (发布订阅)")]),e._v(" "),a("li",[e._v("获取父子组件实例的方式 "),a("code",[e._v("$parent、$children")])]),e._v(" "),a("li",[e._v("在父组件中提供数据子组件进行消费 "),a("code",[e._v("Provide、inject")]),e._v(" 插件")]),e._v(" "),a("li",[a("code",[e._v("Ref")]),e._v(" 获取实例的方式调用组件的属性或者方法(如果给dom写，获取dom元素，如果给组件写，就获取组件的实例)")]),e._v(" "),a("li",[a("code",[e._v("Event Bus")]),e._v(" 实现跨组件通信 Vue.prototype.$bus = new Vue(公共的实例)")]),e._v(" "),a("li",[a("code",[e._v("Vuex")]),e._v(" 状态管理实现通信 $attrs $listeners")])]),e._v(" "),a("h2",{attrs:{id:"_20-vue中相同逻辑如何抽离？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_20-vue中相同逻辑如何抽离？"}},[e._v("#")]),e._v(" 20. Vue中相同逻辑如何抽离？")]),e._v(" "),a("p",[e._v("Vue.mixin 用法 给组件每个生命周期，函数等都混入一些公共逻辑")]),e._v(" "),a("p",[e._v("mixin使用的时候，找不到根源，就是看实例的时候就莫名多个数据")]),e._v(" "),a("h2",{attrs:{id:"_21-为什么要使用异步组件？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_21-为什么要使用异步组件？"}},[e._v("#")]),e._v(" 21.为什么要使用异步组件？")]),e._v(" "),a("p",[e._v("如果组件功能多，打包容量会特别大，需要采用异步组件，主要依赖于import()语法，可以实现文件按需加载")]),e._v(" "),a("p",[e._v("组件的定义，变成函数")]),e._v(" "),a("h2",{attrs:{id:"_22-什么是作用域插槽"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_22-什么是作用域插槽"}},[e._v("#")]),e._v(" 22.什么是作用域插槽")]),e._v(" "),a("p",[a("strong",[e._v("插槽")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('子组件\n<app><div slot="a">xxxx</div><div slot="b">xxxx</div></app>\n父组件\nslot name="a" slot name="b"\n')])])]),a("p",[e._v("创建"),a("strong",[e._v("组件虚拟节点")]),e._v("时候，遇到插槽slot属性，进行分类\n"),a("strong",[e._v("渲染组件")]),e._v("时，拿对应的slot属性的节点进行替换操作（插槽的作用域为父组件）")]),e._v(" "),a("p",[e._v("替换的过程，将父组件设置插槽的节点，设置到对应子组件的插槽里")]),e._v(" "),a("p",[e._v("作用域插槽（作用域在子组件）\n子组件的数据，提供给父组件调用")]),e._v(" "),a("p",[e._v("初始化的时候不会渲染slot的子节点，用一个函数存起来\n当调用的时候，才执行这个函数")]),e._v(" "),a("h2",{attrs:{id:"_23-谈谈你对-keep-alive-的了解？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_23-谈谈你对-keep-alive-的了解？"}},[e._v("#")]),e._v(" 23.谈谈你对 keep-alive 的了解？")]),e._v(" "),a("p",[e._v("keep-alive 可以实现组件的缓存作用\n2个属性 include / exclude\n2个生命周期 activated , deactivated")]),e._v(" "),a("p",[e._v("keep-alive是取第一个组件")]),e._v(" "),a("p",[e._v("用了rlu方法，当超出缓存最长个数时，会将最早缓存删掉")]),e._v(" "),a("h2",{attrs:{id:"_24-vue中常见性能优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_24-vue中常见性能优化"}},[e._v("#")]),e._v(" 24. Vue中常见性能优化")]),e._v(" "),a("ol",[a("li",[e._v("编码优化")])]),e._v(" "),a("ul",[a("li",[e._v("不要将所有的数据都放在data中，可以放在computed， 定时器可以不放data")]),e._v(" "),a("li",[e._v("vue 在 v-for 时给每项元素绑定事件需要用"),a("strong",[e._v("事件代理")])]),e._v(" "),a("li",[e._v("SPA 页面采用keep-alive缓存组件")]),e._v(" "),a("li",[e._v("拆分组件( 提高复用性、增加代码的可维护性,减少不必要的渲染)")]),e._v(" "),a("li",[e._v("key 保证唯一性")]),e._v(" "),a("li",[e._v("合理使用路由懒加载、异步组件")]),e._v(" "),a("li",[e._v("数据持久化的问题 （防抖、节流）")]),e._v(" "),a("li",[e._v("合理使用v-if和v-show")]),e._v(" "),a("li",[e._v("Object.freeze 冻结数据")]),e._v(" "),a("li",[e._v("尽量采用runtime运行时版本")])]),e._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[e._v("Vue 加载性能优化:")])]),e._v(" "),a("ul",[a("li",[e._v("图片懒加载 (https://github.com/hilongjw/vue-lazyload.git)")]),e._v(" "),a("li",[e._v("第三方模块按需导入 (babel-plugin-component)")]),e._v(" "),a("li",[e._v("滚动到可视区域动态加载 (https://tangbc.github.io/vue-virtual-scroll-list)")])]),e._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[e._v("用户体验")])]),e._v(" "),a("ul",[a("li",[e._v("app-skeleton 骨架屏")]),e._v(" "),a("li",[e._v("app-shell app壳")]),e._v(" "),a("li",[e._v("pwa serviceworker")])]),e._v(" "),a("ol",{attrs:{start:"4"}},[a("li",[e._v("SEO 优化：")])]),e._v(" "),a("ul",[a("li",[e._v("预渲染插件 prerender-spa-plugin")]),e._v(" "),a("li",[e._v("服务端渲染 ssr")])]),e._v(" "),a("ol",{attrs:{start:"5"}},[a("li",[e._v("打包优化:")])]),e._v(" "),a("ul",[a("li",[e._v("使用 cdn 的方式加载第三方模块")]),e._v(" "),a("li",[e._v("多线程打包 happypack")]),e._v(" "),a("li",[e._v("splitChunks 抽离公共文件")]),e._v(" "),a("li",[e._v("sourceMap 生成")])]),e._v(" "),a("ol",{attrs:{start:"6"}},[a("li",[e._v("缓存，压缩")])]),e._v(" "),a("ul",[a("li",[e._v("客户端缓存、服务端缓存")]),e._v(" "),a("li",[e._v("服务端 gzip 压缩")])]),e._v(" "),a("h2",{attrs:{id:"_25-vue3-0你知道有哪些改进"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_25-vue3-0你知道有哪些改进"}},[e._v("#")]),e._v(" 25. Vue3.0你知道有哪些改进?")]),e._v(" "),a("ul",[a("li",[e._v("Vue3 采用了TS来编写")]),e._v(" "),a("li",[e._v("支持 Composition API， 解决代码的条理性，mixins混乱问题，")]),e._v(" "),a("li",[e._v("Vue3 中响应式数据原理改成 proxy")]),e._v(" "),a("li",[e._v("vdom 的对比算法更新，只更新 vdom 的绑定了动态数据的部分")])]),e._v(" "),a("h2",{attrs:{id:"_26-实现hash路由和history路由"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_26-实现hash路由和history路由"}},[e._v("#")]),e._v(" 26. 实现hash路由和history路由")]),e._v(" "),a("ul",[a("li",[e._v("onhashchange #")]),e._v(" "),a("li",[e._v("history.pushState h5 api， 页面不存在的问题，所以通过服务端可以解决")])]),e._v(" "),a("p",[e._v("(bilibili vue面试题)[https://www.bilibili.com/video/av90955610?from=search&seid=4442674282775134142]")])])}),[],!1,null,null,null);t.default=r.exports}}]);