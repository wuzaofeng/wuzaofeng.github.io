(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{276:function(t,v,_){"use strict";_.r(v);var s=_(0),r=Object(s.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"重学es6"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#重学es6"}},[t._v("#")]),t._v(" 重学es6")]),t._v(" "),_("h2",{attrs:{id:"循环中的-let-和-const"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#循环中的-let-和-const"}},[t._v("#")]),t._v(" 循环中的 let 和 const")]),t._v(" "),_("h3",{attrs:{id:"let-const特点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#let-const特点"}},[t._v("#")]),t._v(" let, const特点")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("不会变量提升")])]),t._v(" "),_("li",[_("p",[t._v("不能重复定义变量")])]),t._v(" "),_("li",[_("p",[t._v("不能绑定在全局作用域，而是挂在在暂时死区（TDZ）")])])]),t._v(" "),_("h3",{attrs:{id:"块级作用域"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#块级作用域"}},[t._v("#")]),t._v(" 块级作用域")]),t._v(" "),_("p",[t._v("ES5 规定，函数只能在"),_("strong",[t._v("顶层作用域和函数作用域")]),t._v("之中声明，不能在"),_("strong",[t._v("块级作用域声明")])]),t._v(" "),_("p",[t._v("ES6")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("允许在块级作用域内声明函数")])]),t._v(" "),_("li",[_("p",[t._v("函数声明类似于var，即会提升到全局作用域或函数作用域的头部")])]),t._v(" "),_("li",[_("p",[t._v("同时，函数声明还会提升到所在的块级作用域的头部")])])]),t._v(" "),_("ol",[_("li",[_("p",[t._v("for循环，通过let声明，会生成一个块级作用域，每次迭代循环时都"),_("strong",[t._v("创建一个新变量")]),t._v("，并且会"),_("strong",[t._v("修改")]),t._v("循环迭代之前同名的变量， const声明为报错，因为是const声明是常量，不能被修改")])]),t._v(" "),_("li",[_("p",[t._v("for in遍历对象, let声明，const声明是可以通过，因为不会修改之前的\n同名变量")])])]),t._v(" "),_("h2",{attrs:{id:"解构赋值"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#解构赋值"}},[t._v("#")]),t._v(" 解构赋值")]),t._v(" "),_("p",[t._v("解构赋值可以解构"),_("strong",[t._v("数组，对象，数字，字符串，函数参数")]),t._v("， 但不能解构"),_("code",[t._v("undefined")]),t._v(", "),_("code",[t._v("null")])]),t._v(" "),_("ol",[_("li",[_("p",[t._v("解构赋值优先使用"),_("strong",[t._v("判断右边有没有值")]),t._v("，"),_("strong",[t._v("没有值才取默认值")])])]),t._v(" "),_("li",[_("p",[t._v("如果右边是"),_("code",[t._v("undefined")]),t._v("，会取默认值，但"),_("code",[t._v("null")]),t._v("不会")])]),t._v(" "),_("li",[_("p",[t._v("如果要将已经声明的变量解构赋值，需要加"),_("strong",[t._v("圆括号")])])]),t._v(" "),_("li",[_("p",[t._v("数字，字符串解构会先传成包装对象")])])]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("\n\x3c!-- 错误的写法, 因为Javascript引擎会将{x}理解成一个代码块 --\x3e\nlet x;\n{x} = {x: 1};\n// SyntaxError: syntax error\n\n// 正确的写法\nlet x;\n({x} = {x: 1});\n\n")])])]),_("h3",{attrs:{id:"用途"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#用途"}},[t._v("#")]),t._v(" 用途")]),t._v(" "),_("ol",[_("li",[_("p",[_("strong",[t._v("交换变量")]),t._v("的值")])]),t._v(" "),_("li",[_("p",[t._v("从"),_("strong",[t._v("函数返回")]),t._v("直接获取多个值")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("函数参数的定义")]),t._v("直接获取值")])]),t._v(" "),_("li",[_("p",[t._v("快速提取"),_("strong",[t._v("对象，数组")]),t._v("数据")])]),t._v(" "),_("li",[_("p",[t._v("函数参数"),_("strong",[t._v("设置默认值")])])])]),t._v(" "),_("h2",{attrs:{id:"字符串的扩展"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#字符串的扩展"}},[t._v("#")]),t._v(" 字符串的扩展")]),t._v(" "),_("ol",[_("li",[t._v("加强对字符的"),_("code",[t._v("Unicode")]),t._v("的支持，")])]),t._v(" "),_("h2",{attrs:{id:"原始symbol，表示独一无二的值"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#原始symbol，表示独一无二的值"}},[t._v("#")]),t._v(" 原始Symbol，表示独一无二的值")]),t._v(" "),_("ol",[_("li",[_("p",[t._v("Symbol 函数创建， 不能通过new创建")])]),t._v(" "),_("li",[_("p",[t._v("instanceof 结果是false")])]),t._v(" "),_("li",[_("p",[t._v("Symbol 不能与其他类型运算")])]),t._v(" "),_("li",[_("p",[t._v("Symbol 作为属性名，该属性不会出现在 for...in、for...of 循环中，也不会被 Object.keys()、Object.getOwnPropertyNames()、JSON.stringify() 返回. 可以用Object.getOwnPropertySymbols方法调用")])])]),t._v(" "),_("p",[t._v("用途，挂在全局对象做单例模式")]),t._v(" "),_("h2",{attrs:{id:"for-of-循环（实际上就是调用symbol-iterator）"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#for-of-循环（实际上就是调用symbol-iterator）"}},[t._v("#")]),t._v(" for...of 循环（实际上就是调用Symbol.iterator）")]),t._v(" "),_("ol",[_("li",[t._v("数组")]),t._v(" "),_("li",[t._v("Set")]),t._v(" "),_("li",[t._v("Map")]),t._v(" "),_("li",[t._v("类数组对象，如 arguments 对象、DOM NodeList 对象")]),t._v(" "),_("li",[t._v("Generator 对象")]),t._v(" "),_("li",[t._v("字符串")])]),t._v(" "),_("h2",{attrs:{id:"promise"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#promise"}},[t._v("#")]),t._v(" Promise")]),t._v(" "),_("h3",{attrs:{id:"回调地狱的坏处"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#回调地狱的坏处"}},[t._v("#")]),t._v(" 回调地狱的坏处")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("可读性差，通过函数嵌套函数")])]),t._v(" "),_("li",[_("p",[t._v("难以复用")])]),t._v(" "),_("li",[_("p",[t._v("借助外层的变量")])]),t._v(" "),_("li",[_("p",[t._v("有时候同步执行，异步函数无法区分开来")])])]),t._v(" "),_("h3",{attrs:{id:"promise-的局限性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#promise-的局限性"}},[t._v("#")]),t._v(" Promise 的局限性")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("错误被吃掉，Promise 内部的错误不会影响到 Promise 外部的代码")])]),t._v(" "),_("li",[_("p",[t._v("resolve, reject只能传递单一值")])]),t._v(" "),_("li",[_("p",[t._v("无法取消")])]),t._v(" "),_("li",[_("p",[t._v("无法知道pending状态")])])])])}),[],!1,null,null,null);v.default=r.exports}}]);