(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{267:function(n,t,e){"use strict";e.r(t);var s=e(0),a=Object(s.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"【好文】从javascript中看设计模式-总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#【好文】从javascript中看设计模式-总结"}},[n._v("#")]),n._v(" 【好文】从JavaScript中看设计模式(总结)")]),n._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[n._v("概念")]),n._v(" "),e("p",[n._v("设计模式 (Design Pattern) 是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结")])]),n._v(" "),e("p",[n._v("任何事情都有套路，"),e("code",[n._v("设计模式")]),n._v("就是写代码中常见的套路，有些写法我们日常都在使用，下面我们来介绍一下")]),n._v(" "),e("p",[e("strong",[n._v("创建设计模式")]),n._v("：工厂，单例、建造者、原型")]),n._v(" "),e("p",[e("strong",[n._v("结构化设计模式")]),n._v("：外观，适配器，代理，装饰器，享元，桥接，组合")]),n._v(" "),e("p",[e("strong",[n._v("行为型模式")]),n._v("：策略、模板方法、观察者、迭代器、责任链、命令、备忘录、状态、访问者、终结者、解释器")]),n._v(" "),e("h2",{attrs:{id:"订阅-发布模式-观察者"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#订阅-发布模式-观察者"}},[n._v("#")]),n._v(" 订阅/发布模式(观察者)")]),n._v(" "),e("p",[n._v("在这种模式中，并不是一个对象调用另一个对象的方法，而是一个对象"),e("code",[n._v("订阅")]),n._v("另一个对象")]),n._v(" "),e("p",[n._v("特定活动并在状态改变后获得通知，订阅者因此也成为观察者，而被观察的对象成为发布者或主题。当发生了一个重要事件的时候"),e("code",[n._v("发布者")]),n._v("会通知（调用）所有"),e("code",[n._v("订阅者")]),n._v("并且可能经常以"),e("code",[n._v("事件对象")]),n._v("的形式传递消息。")]),n._v(" "),e("p",[e("strong",[n._v("自己实现一个简单的发布订阅设计模式")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('// 订阅/发布者模式\nclass EventBus {\n  constructor () {\n    // 存储事件\n    this.tasks = {}\n  }\n\n  // 绑定事件\n  $on(eName, cb) {\n    // 判断传入是否是函数，如果是函数则在task添加属性\n    typeof cb === \'function\' ? this.tasks[eName] || (this.tasks[eName] = []) :  this.Error(cb, \'is not a function\')\n\n    // 避免重复绑定，如果不存在则将cb函数添加进tasks的属性中\n    this.tasks[eName].some(fn => fn == cb) ? true : this.tasks[eName].push(cb)\n  }\n\n  // 触发事件\n  $emit(eName, ...arg) {\n    let taskQueue;\n    // 获取事件列\n    this.tasks[eName] && this.tasks[eName].length > 0 ? (taskQueue = this.tasks[eName]) : this.Error(eName, \'is not defined or is a array of having empty callback\')\n    // 遍历task事件，并且执行事件列\n    debugger\n    taskQueue.forEach(fn => fn(...arg))\n  }\n\n  // 触发一次\n  $once(eName, cb) {\n    let fn = (...arg) => {\n      // 删除订阅\n      this.$off(eName, fn)\n      cb(...arg)\n    }\n\n    typeof cb === \'function\' && this.$on(eName, fn)\n  }\n\n  // 卸载事件\n  $off(eName, cb) {\n    let taskQueue;\n    this.tasks[eName] && this.tasks[eName].length > 0\n      ? (taskQueue = this.tasks[eName])\n      : this.Error(eName, "is not exist");\n    if (typeof cb === "function") {\n      // 单独删除事件\n      let index = taskQueue.findIndex(v => (v == cb));\n      index != -1 &&\n        taskQueue.splice(\n          taskQueue.findIndex(v => (v == cb)),\n          1\n        );\n    }\n    // 删除事件列\n    if (typeof cb === "undefined") {\n      taskQueue.length = 0;\n    }\n  }\n  // 异常处理\n  Error(node, errorMsg) {\n    throw Error(`${node} ${errorMsg}`);\n  }\n}\n\n// 首先定义一个事件池\nconst EventSinks = {\n  add(x, y) {\n    console.log("总和: " + (x + y));\n  },\n  multip(x, y) {\n    console.log("乘积: " + x * y);\n  },\n  onceEvent() {\n    console.log("我执行一次后就自动卸载");\n  }\n};\n')])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('// 实例化对象\nlet bus = new EventBus();\nbus.$on("operator", EventSinks.add); // 监听operator事件, 增加一个EventSinks.add\nbus.$on("operator", EventSinks.add); // 当事件名和回调函数相同时，跳过，避免重复绑定\nbus.$on("operator", EventSinks.multip); // 给operator事件增加一个EventSinks.multip回调函数\nbus.$once("onceEvent", EventSinks.onceEvent); // 触发一次后卸载\nconsole.log(bus.tasks); // { operator: [ [Function: add], [Function: multip] ], onceEvent: [ [Function: fn] ]}\n\nbus.$emit("operator", 3, 5); // 总和:8  乘积:15\nbus.$emit("onceEvent"); // 我就执行一次\nconsole.log(bus.tasks); // { operator: [ [Function: add], [Function: multip] ], onceEvent: [] }\nbus.$off("operator", EventSinks.add); // 卸载掉operator事件中的EventSinks.add函数体\nconsole.log(bus.tasks); // { operator: [ [Function: multip] ], onceEvent: [] }\nbus.$off("operator"); // 卸载operator事件的所有回调函数\nconsole.log(bus.tasks); // { operator: [], onceEvent: [] }\nbus.$emit("onceEvent"); // onceEvent is not defined or is a array of having empty callback\n\n')])])]),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[n._v("总结")]),n._v(" "),e("p",[n._v("EventBus 就是所谓的发布者的构造函数，当中的bus就是发布者的一个实例")]),n._v(" "),e("p",[n._v("我们调用$on, $once时，就是自定义订阅事件列")]),n._v(" "),e("p",[n._v("但我们调用$emit时，就是通知（发布）（执行）对应事件列")]),n._v(" "),e("p",[n._v("那么bus就是发布者")]),n._v(" "),e("p",[n._v("这个就是简单观察者模式，更高级的就是订阅发布者模式")])]),n._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[n._v("观察者和发布订阅者模式的区别")]),n._v(" "),e("p",[n._v("从表面上看：")]),n._v(" "),e("p",[n._v("观察者模式里，只有两个角色 —— "),e("strong",[n._v("观察者 + 被观察者")]),n._v("\n而发布订阅模式里，却不仅仅只有"),e("strong",[n._v("发布者和订阅者")]),n._v("两个角色，还有一个经常被我们忽略的 —— "),e("strong",[n._v("经纪人Broker")]),n._v("\n往更深层次讲：")]),n._v(" "),e("p",[n._v("观察者和被观察者，是松耦合的关系\n发布者和订阅者，则完全不存在耦合\n从使用层面上讲：")]),n._v(" "),e("p",[n._v("观察者模式，多用于"),e("strong",[n._v("单个应用内部")]),n._v("\n发布订阅模式，则更多的是一种"),e("strong",[n._v("跨应用的模式")]),n._v("(cross-application pattern)，比如我们"),e("strong",[n._v("常用的消息中间件")])]),n._v(" "),e("p",[e("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/51357583",target:"_blank",rel:"noopener noreferrer"}},[n._v("观察者模式和订阅发布者模式是一样么？"),e("OutboundLink")],1)])]),n._v(" "),e("h2",{attrs:{id:"策略模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#策略模式"}},[n._v("#")]),n._v(" 策略模式")]),n._v(" "),e("p",[n._v("策略模式的目的就是将算法的"),e("strong",[n._v("使用算法的实现分离")]),n._v("出来")]),n._v(" "),e("p",[n._v("一个基于策略模式的程序至少由两部分组成。第一部分是一组"),e("code",[n._v("策略类")]),n._v("（可变），策略类封装了具体的算法，并负责具体的计算过程。第二部分是"),e("code",[n._v("环境类Context")]),n._v("（不变），"),e("code",[n._v("Context")]),n._v("接受客户的请求，随后将请求委托给某一个"),e("code",[n._v("策略类")]),n._v("。要做到这一点，说明Context中要维持对某个策略对象的引用")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('// 普通写法\nconst form = document.querySelector("#form");\nform.onsubmit = () => {\n  if (form.username.value == "") {\n    console.log("用户名不能为空");\n    return false;\n  }\n  if(form.username.password.length < 10){\n    console.log(\'密码长度不能小于10\')\n    return false\n  }\n}\n')])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("// 创建校验器\nconst checker = {\n  isEmpty(v, errorMsg){\n    if(value === ''){\n      return errorMsg\n    }\n  },\n  minLength(v, length, errorMsg){\n    if(value.length < length){\n      return errorMsg\n    }\n  }\n}\nconst validator = () => {\n  // 校验规则存储\n  this.cache = []\n}\nvalidator.prototype.add = (...rule) => {\n  let arr = rule.split(',')\n  this.cache.push(() => {\n    let valit = arr.shift()\n    arr.unshift(dom.value)\n    arr.push(errorMsg)\n    return checker[valit].apply(dom, arr)\n  })\n}\nvalidator.prototype.start = () => {\n  for(let i = 0, validatorFunc; validatorFunc = this.cache[i++];){\n    // 开始校验，并取得校验后的返回值\n    let msg = validatorFunc() \n    if(msg){\n      return msg\n    }\n  }\n}\nconst validatorFunc = () => {\n  // 创建一个validator对象\n  let valit = new validator() \n  valit.add(form.username, 'isEmpty', '用户名不能为空')\n  valit.add(form.password, 'minLength', '密码长度不能小于10')\n  // 获得校验结果\n  let errorMsg = valit.start()  \n  return errorMsg  \n}\n\n// 再次登录\nconst form = document.querySelector(\"#form\");\nform.onsubmit = () => {\n  let errorMsg = validatorFunc()\n  if(errorMsg){\n    console.error(errorMsg)\n    return false\n  }\n}\n")])])]),e("p",[n._v("当创建校验器后，校验规则清晰明了，可以动态增改，便于维护\n所谓的校验器就是策略类，而提供外部的validatorFunc方法则是环境类")]),n._v(" "),e("h2",{attrs:{id:"迭代器模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#迭代器模式"}},[n._v("#")]),n._v(" 迭代器模式")]),n._v(" "),e("p",[e("strong",[n._v("迭代器模式定义")]),n._v("：指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。")]),n._v(" "),e("p",[n._v("迭代器模式可以"),e("strong",[n._v("把迭代的过程")]),n._v("从业务逻辑中分离出来，在使用迭代器模式之后，即使不关心对象的内部构造，也可以按顺序访问其中的每个元素")]),n._v(" "),e("p",[n._v("比如常用的：every、map、filter、forEach等等")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("const each = function(arr, callback){\n  if(!Array.isArray(arr)){\n    throw Error(`${arr} is not a Array`)\n  }\n  for(let i = 0, l = arr.length; i < l; i++){\n    callback.call(arr[i], i, arr[i])\n  }\n}\neach([1,2,4], function(i, n){\n  console.log([i, n])\n})\n\x3c!-- [0, 1] --\x3e\n\x3c!-- [1, 2] --\x3e\n\x3c!-- [2, 4] --\x3e\n")])])])])}),[],!1,null,null,null);t.default=a.exports}}]);