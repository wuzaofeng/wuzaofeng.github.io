(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{371:function(t,v,a){"use strict";a.r(v);var e=a(10),_=Object(e.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"前端面试之道的理解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#前端面试之道的理解"}},[t._v("#")]),t._v(" 前端面试之道的理解")]),t._v(" "),v("h2",{attrs:{id:"总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),v("h3",{attrs:{id:"原始类型-对象类型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#原始类型-对象类型"}},[t._v("#")]),t._v(" 原始类型, 对象类型")]),t._v(" "),v("p",[t._v("1.number浮点类型的换算问题")]),t._v(" "),v("p",[t._v("2.string类型是不可变的")]),t._v(" "),v("p",[t._v("3.null不是对象，但typeof null输出对象，"),v("strong",[t._v("历史悠久问题")]),t._v("，为了性能考虑使用的"),v("strong",[t._v("低位存储变量")]),t._v("的类型信息， 000开头代表对象，null表示全为0")]),t._v(" "),v("p",[t._v("4.typeof判断原始类型，除了null，其他都可以判断，但判断对象，除了函数能判断出来，其他都是object")]),t._v(" "),v("p",[t._v("5.可以通过[Symbol.hasInstance] 让"),v("code",[t._v("instanceof")]),t._v("判断原始类型")]),t._v(" "),v("h3",{attrs:{id:"类型转换"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#类型转换"}},[t._v("#")]),t._v(" 类型转换")]),t._v(" "),v("ol",[v("li",[t._v("除了undefined, null, false, NaN, '', 0, -0, 其他所有值都转成true, 包括对象")])]),t._v(" "),v("p",[t._v("2.对象转原始类型，会调用内置"),v("code",[t._v("[[ToPrimitive]]")]),t._v("\n该算法逻辑，如果已经是原始类型，就不转换，如果是字符串就通过"),v("code",[t._v("toString")]),t._v("方法，否则就先用"),v("code",[t._v("valueOf")]),t._v("，如果是基础类型就返回，没有的话就再调用"),v("code",[t._v("toString")]),t._v(", 如果是对象调用"),v("code",[t._v("valueOf")]),t._v("返回对象")])])}),[],!1,null,null,null);v.default=_.exports}}]);