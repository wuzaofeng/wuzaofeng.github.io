(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{242:function(n,e,t){"use strict";t.r(e);var s=t(0),a=Object(s.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"【好文】从javascript中看设计模式-总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#【好文】从javascript中看设计模式-总结"}},[n._v("#")]),n._v(" 【好文】从JavaScript中看设计模式(总结)")]),n._v(" "),t("p",[n._v("::: tips 概念\n设计模式 (Design Pattern) 是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结\n:::")]),n._v(" "),t("p",[n._v("任何事情都有套路，"),t("code",[n._v("设计模式")]),n._v("就是写代码中常见的套路，有些写法我们日常都在使用，下面我们来介绍一下")]),n._v(" "),t("p",[t("strong",[n._v("创建设计模式")]),n._v("：工厂，单例、建造者、原型")]),n._v(" "),t("p",[t("strong",[n._v("结构化设计模式")]),n._v("：外观，适配器，代理，装饰器，享元，桥接，组合")]),n._v(" "),t("p",[t("strong",[n._v("行为型模式")]),n._v("：策略、模板方法、观察者、迭代器、责任链、命令、备忘录、状态、访问者、终结者、解释器")]),n._v(" "),t("h2",{attrs:{id:"行为型模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#行为型模式"}},[n._v("#")]),n._v(" 行为型模式")]),n._v(" "),t("h3",{attrs:{id:"订阅-发布模式-观察者"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#订阅-发布模式-观察者"}},[n._v("#")]),n._v(" 订阅/发布模式(观察者)")]),n._v(" "),t("p",[n._v("在这种模式中，并不是一个对象调用另一个对象的方法，而是一个对象"),t("code",[n._v("订阅")]),n._v("另一个对象")]),n._v(" "),t("p",[n._v("特定活动并在状态改变后获得通知，订阅者因此也成为观察者，而被观察的对象成为发布者或主题。当发生了一个重要事件的时候"),t("code",[n._v("发布者")]),n._v("会通知（调用）所有"),t("code",[n._v("订阅者")]),n._v("并且可能经常以"),t("code",[n._v("事件对象")]),n._v("的形式传递消息。")]),n._v(" "),t("p",[t("strong",[n._v("自己实现一个简单的发布订阅设计模式")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('// 订阅/发布者模式\nclass EventBus {\n  constructor () {\n    // 存储事件\n    this.tasks = {}\n  }\n\n  // 绑定事件\n  $on(eName, cb) {\n    // 判断传入是否是函数，如果是函数则在task添加属性\n    typeof cb === \'function\' ? this.tasks[eName] || (this.tasks[eName] = []) :  this.Error(cb, \'is not a function\')\n\n    // 避免重复绑定，如果不存在则将cb函数添加进tasks的属性中\n    this.tasks[eName].some(fn => fn == cb) ? true : this.tasks[eName].push(cb)\n  }\n\n  // 触发事件\n  $emit(eName, ...arg) {\n    let taskQueue;\n    // 获取事件列\n    this.tasks[eName] && this.tasks[eName].length > 0 ? (taskQueue = this.tasks[eName]) : this.Error(eName, \'is not defined or is a array of having empty callback\')\n    // 遍历task事件，并且执行事件列\n    debugger\n    taskQueue.forEach(fn => fn(...arg))\n  }\n\n  // 触发一次\n  $once(eName, cb) {\n    let fn = (...arg) => {\n      // 删除订阅\n      this.$off(eName, fn)\n      cb(...arg)\n    }\n\n    typeof cb === \'function\' && this.$on(eName, fn)\n  }\n\n  // 卸载事件\n  $off(eName, cb) {\n    let taskQueue;\n    this.tasks[eName] && this.tasks[eName].length > 0\n      ? (taskQueue = this.tasks[eName])\n      : this.Error(eName, "is not exist");\n    if (typeof cb === "function") {\n      // 单独删除事件\n      let index = taskQueue.findIndex(v => (v == cb));\n      index != -1 &&\n        taskQueue.splice(\n          taskQueue.findIndex(v => (v == cb)),\n          1\n        );\n    }\n    // 删除事件列\n    if (typeof cb === "undefined") {\n      taskQueue.length = 0;\n    }\n  }\n  // 异常处理\n  Error(node, errorMsg) {\n    throw Error(`${node} ${errorMsg}`);\n  }\n}\n\n// 首先定义一个事件池\nconst EventSinks = {\n  add(x, y) {\n    console.log("总和: " + (x + y));\n  },\n  multip(x, y) {\n    console.log("乘积: " + x * y);\n  },\n  onceEvent() {\n    console.log("我执行一次后就自动卸载");\n  }\n};\n')])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('// 实例化对象\nlet bus = new EventBus();\nbus.$on("operator", EventSinks.add); // 监听operator事件, 增加一个EventSinks.add\nbus.$on("operator", EventSinks.add); // 当事件名和回调函数相同时，跳过，避免重复绑定\nbus.$on("operator", EventSinks.multip); // 给operator事件增加一个EventSinks.multip回调函数\nbus.$once("onceEvent", EventSinks.onceEvent); // 触发一次后卸载\nconsole.log(bus.tasks); // { operator: [ [Function: add], [Function: multip] ], onceEvent: [ [Function: fn] ]}\n\nbus.$emit("operator", 3, 5); // 总和:8  乘积:15\nbus.$emit("onceEvent"); // 我就执行一次\nconsole.log(bus.tasks); // { operator: [ [Function: add], [Function: multip] ], onceEvent: [] }\nbus.$off("operator", EventSinks.add); // 卸载掉operator事件中的EventSinks.add函数体\nconsole.log(bus.tasks); // { operator: [ [Function: multip] ], onceEvent: [] }\nbus.$off("operator"); // 卸载operator事件的所有回调函数\nconsole.log(bus.tasks); // { operator: [], onceEvent: [] }\nbus.$emit("onceEvent"); // onceEvent is not defined or is a array of having empty callback\n\n')])])]),t("p",[n._v("::: tips 总结\nEventBus 就是所谓的发布者的构造函数，当中的bus就是发布者的一个实例")]),n._v(" "),t("p",[n._v("我们调用$on, $once时，就是自定义订阅事件列")]),n._v(" "),t("p",[n._v("但我们调用$emit时，就是通知（发布）（执行）对应事件列")]),n._v(" "),t("p",[n._v("那么bus就是发布者")]),n._v(" "),t("p",[n._v("这个就是简单观察者模式，更高级的就是订阅发布者模式")]),n._v(" "),t("p",[t("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/51357583",target:"_blank",rel:"noopener noreferrer"}},[n._v("观察者模式和订阅发布者模式是一样么？"),t("OutboundLink")],1),n._v("\n:::")]),n._v(" "),t("h2",{attrs:{id:"创建设计模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#创建设计模式"}},[n._v("#")]),n._v(" 创建设计模式")]),n._v(" "),t("h3",{attrs:{id:"单例模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#单例模式"}},[n._v("#")]),n._v(" 单例模式")]),n._v(" "),t("p",[n._v("::: tips 定义\n单例模式的定义："),t("code",[n._v("保证一个类仅有一个实例")]),n._v("，并提供一个访问它的全局访问点。实现的方法为"),t("code",[n._v("先判断实例存在与否")]),n._v("，如果存在则直接返回，否则就创建实例再返回，这就"),t("code",[n._v("保证了一个类只实例化一次")]),n._v("\n:::")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("class Singleton {\n  constructor() {}\n}\n\nSingleton.getInstance = (function() {\n  let instance\n  return function() {\n    // 判断是否有存在的实例，如果没有就创建实例，否则就返回存在的实例\n    if (!instance) {\n      instance = new Singleton()\n    }\n    // 闭包的作用导致instance存在于内存中\n    return instance\n  }\n})()\n\nlet s1 = Singleton.getInstance()\nlet s2 = Singleton.getInstance()\nconsole.log(s1 === s2) // true\n\n")])])])])}),[],!1,null,null,null);e.default=a.exports}}]);