(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{229:function(n,t,e){n.exports=e.p+"assets/img/proto.5e18c31b.png"},266:function(n,t,e){"use strict";e.r(t);var v=e(0),a=Object(v.a)({},(function(){var n=this,t=n.$createElement,v=n._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[v("h2",{attrs:{id:"原型以及原型链"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#原型以及原型链"}},[n._v("#")]),n._v(" 原型以及原型链")]),n._v(" "),v("h3",{attrs:{id:"原型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#原型"}},[n._v("#")]),n._v(" 原型")]),n._v(" "),v("p",[n._v("本质是一个js对象(除了"),v("code",[n._v("null")]),n._v(")，当我们通过"),v("strong",[n._v("构造函数")]),n._v("创建"),v("strong",[n._v("实例")]),n._v("的时候，构造函数的其中一个属性"),v("code",[n._v("prototype")]),n._v("指向"),v("strong",[n._v("原型")]),n._v("，"),v("strong",[n._v("实例")]),n._v("的"),v("code",[n._v("_proto_")]),n._v("指向"),v("strong",[n._v("原型")])]),n._v(" "),v("p",[n._v("实例对象与原型对象之间通过"),v("code",[n._v("_proto_")]),n._v("来关联起来，当实例的属性找不到的时候会通过"),v("code",[n._v("_proto")]),n._v("继续往上层原型对象查找，直到找到"),v("code",[n._v("Object.prototype")]),n._v("为止")]),n._v(" "),v("p",[n._v("用于创建出来的实例共享属性以及方法")]),n._v(" "),v("h3",{attrs:{id:"原型链"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#原型链"}},[n._v("#")]),n._v(" 原型链")]),n._v(" "),v("p",[v("strong",[n._v("原型链")]),n._v("是通过实例的"),v("code",[n._v("_proto")]),n._v("属性，查找原型对象，如果找不到，会往上查找。这样成为一个原型链，一般是用于继承")]),n._v(" "),v("p",[n._v("关于Function__proto__===Function.prototype的问题")]),n._v(" "),v("p",[v("a",{attrs:{href:"https://github.com/jawil/blog/issues/13",target:"_blank",rel:"noopener noreferrer"}},[n._v("从探究Function."),v("strong",[n._v("proto")]),n._v("===Function.prototype过程中的一些收获"),v("OutboundLink")],1)]),n._v(" "),v("p",[v("img",{attrs:{src:e(229),alt:"原型图"}})]),n._v(" "),v("h2",{attrs:{id:"作用域"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#作用域"}},[n._v("#")]),n._v(" 作用域")]),n._v(" "),v("p",[n._v("js是"),v("strong",[n._v("词法作用域")]),n._v("，也就是"),v("strong",[n._v("静态作用域")])]),n._v(" "),v("p",[v("strong",[n._v("静态作用域")]),n._v("是，函数作用域在**(函数定义)**的时候就决定了 (该作用域是父级创建的所以作用域链)")]),n._v(" "),v("p",[v("strong",[n._v("动态作用域")]),n._v("是，函数作用域在"),v("strong",[n._v("函数调用")]),n._v("的时候才决定的。")]),n._v(" "),v("h3",{attrs:{id:"个人理解作用域"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#个人理解作用域"}},[n._v("#")]),n._v(" 个人理解作用域")]),n._v(" "),v("p",[n._v("作用域有两种")]),n._v(" "),v("p",[n._v("一种是函数创建的时候，会有个"),v("strong",[n._v("静态作用域")]),n._v("，静态作用域是指将父级或父级以上的作用域的所有变量对象，可以理解成一个"),v("strong",[n._v("父级的作用域链")])]),n._v(" "),v("p",[n._v("第二种，就是函数执行的时候，会创建一个执行上下文，也就是会创建一个作用域，是函数独有的作用域，两者加起来就是该函数整体的作用域")]),n._v(" "),v("h2",{attrs:{id:"执行上下文"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#执行上下文"}},[n._v("#")]),n._v(" 执行上下文")]),n._v(" "),v("p",[n._v("js引擎执行代码时会创建执行环境（执行上下文）")]),n._v(" "),v("ul",[v("li",[v("p",[n._v("创建全局函数")])]),n._v(" "),v("li",[v("p",[n._v("函数执行")])]),n._v(" "),v("li",[v("p",[n._v("eval方法调用")])])]),n._v(" "),v("h3",{attrs:{id:"生命周期"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#生命周期"}},[n._v("#")]),n._v(" 生命周期")]),n._v(" "),v("p",[n._v("创建阶段\n在这个阶段中，执行上下文会分别创建变量对象，建立作用域链，以及确定this的指向。")]),n._v(" "),v("p",[n._v("代码执行阶段\n创建完成之后，就会开始执行代码，这个时候，会完成变量赋值，函数引用，以及执行其他代码")]),n._v(" "),v("h3",{attrs:{id:"执行上下文都会包含三个重要属性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#执行上下文都会包含三个重要属性"}},[n._v("#")]),n._v(" "),v("strong",[n._v("执行上下文都会包含三个重要属性")])]),n._v(" "),v("ol",[v("li",[v("p",[n._v("变量对象（variable Object VO）")])]),n._v(" "),v("li",[v("p",[n._v("作用域链（scoped chain）")])]),n._v(" "),v("li",[v("p",[n._v("this")])])]),n._v(" "),v("h4",{attrs:{id:"变量对象-vo"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#变量对象-vo"}},[n._v("#")]),n._v(" 变量对象(VO)")]),n._v(" "),v("ol",[v("li",[v("p",[n._v("函数的所有形参（如果是函数上下文）")]),n._v(" "),v("ul",[v("li",[v("p",[n._v("由"),v("strong",[n._v("名称和对应值")]),n._v("组成的一个变量对象的属性被创建")])]),n._v(" "),v("li",[v("p",[n._v("没有实参，为undefined")])])])]),n._v(" "),v("li",[v("p",[n._v("函数声明")]),n._v(" "),v("ul",[v("li",[v("p",[n._v("由"),v("strong",[n._v("名称和对应值")]),n._v("（函数对象(function-object)）组成一个变量对象的属性被创建")])]),n._v(" "),v("li",[v("p",[n._v("如果变量对象已经存在相同名称的属性，则"),v("strong",[n._v("完全替换")]),n._v("这个属性")])])])]),n._v(" "),v("li",[v("p",[n._v("变量声明")]),n._v(" "),v("ul",[v("li",[v("p",[n._v("由"),v("strong",[n._v("名称和对应值")]),n._v("（undefined）组成一个变量对象的属性被创建；")])]),n._v(" "),v("li",[v("p",[n._v("如果变量名称跟已经声明的形式参数或函数相同，则变量声明"),v("strong",[n._v("不会干扰")]),n._v("已经存在的这类属性")])])])])]),n._v(" "),v("h5",{attrs:{id:"变量对象（vo）与活动对象（ao）区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#变量对象（vo）与活动对象（ao）区别"}},[n._v("#")]),n._v(" 变量对象（VO）与活动对象（AO）区别")]),n._v(" "),v("p",[n._v("当每次执行上下文之前，会保存上下文定义的属性以及函数声明, 该阶段是不可访问")]),n._v(" "),v("p",[n._v("但执行阶段之后，变量对象（VO）会转成 活动对象（AO）,里面的属性可以访问")]),n._v(" "),v("p",[n._v("本质上都是同一个对象，区别在于运行不同的对象周期")]),n._v(" "),v("p",[v("a",{attrs:{href:"https://github.com/mqyqingfeng/Blog/issues/6",target:"_blank",rel:"noopener noreferrer"}},[n._v("JavaScript深入之作用域链 "),v("OutboundLink")],1)]),n._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[n._v("总结")]),n._v(" "),v("ol",[v("li",[v("p",[n._v("全局上下文的"),v("strong",[n._v("变量对象")]),n._v("初始化是全局对象 (window)")])]),n._v(" "),v("li",[v("p",[n._v("函数上下文的"),v("strong",[n._v("变量对象")]),n._v("初始化只包括 Arguments 对象")])]),n._v(" "),v("li",[v("p",[n._v("在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值")])]),n._v(" "),v("li",[v("p",[n._v("在代码执行阶段，会再次修改变量对象的属性值")])])])]),n._v(" "),v("h2",{attrs:{id:"this"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#this"}},[n._v("#")]),n._v(" this")]),n._v(" "),v("h3",{attrs:{id:"从ecmascript规范"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#从ecmascript规范"}},[n._v("#")]),n._v(" 从ECMAScript规范")]),n._v(" "),v("p",[n._v("判断this")]),n._v(" "),v("ol",[v("li",[v("p",[n._v("计算 "),v("code",[n._v("MemberExpression")]),n._v(" 的结果赋值给 "),v("code",[n._v("ref")]),n._v(" "),v("code",[n._v("MemberExpression")]),n._v(" 左边表达式")])]),n._v(" "),v("li",[v("p",[n._v("判断 "),v("code",[n._v("ref")]),n._v(" 是不是一个 "),v("code",[n._v("Reference")]),n._v(" 类型。")])])]),n._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[n._v("2.1 如果 ref 是 Reference，并且 IsPropertyReference(ref) 是 true, 那么 this 的值为 GetBase(ref)\n\n2.2 如果 ref 是 Reference，并且 base value 值是 Environment Record, 那么this的值为 ImplicitThisValue(ref)\n\n2.3 如果 ref 不是 Reference，那么 this 的值为 undefined\n")])])]),v("p",[n._v("由于不是严格模式，this如果是undefined，会指向全局对象window")]),n._v(" "),v("p",[v("a",{attrs:{href:"https://github.com/mqyqingfeng/Blog/issues/7",target:"_blank",rel:"noopener noreferrer"}},[n._v("JavaScript深入之从ECMAScript规范解读this"),v("OutboundLink")],1)]),n._v(" "),v("h3",{attrs:{id:"常规理解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常规理解"}},[n._v("#")]),n._v(" 常规理解")]),n._v(" "),v("p",[n._v("this就是最后调用他的函数，")]),n._v(" "),v("ol",[v("li",[v("p",[n._v("直接调用 window （window 绑定）")])]),n._v(" "),v("li",[v("p",[n._v("对象调用指向对象 （隐式绑定）")])]),n._v(" "),v("li",[v("p",[n._v("new 调用指向实例 （new 绑定）")])]),n._v(" "),v("li",[v("p",[n._v("可以通过call， apply, bind改变（显式绑定）")])])]),n._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[n._v("1. 查看函数在哪被调用。\n2. 左侧有没有对象？如果有，它就是 “this” 的引用。如果没有，继续第 3 步。\n3. 该函数是不是用 “call”、“apply” 或者 “bind” 调用的？如果是，它会显式地指明 “this” 的引用。如果不是，继续第 4 步。\n4. 该函数是不是用 “new” 调用的？如果是，“this” 指向的就是 JavaScript 解释器新创建的对象。如果不是，继续第 5 步。\n5. 是否在“严格模式”下？如果是，“this” 就是 undefined，如果不是，继续第 6 步。\n6. JavaScript 很奇怪，“this” 会指向 “window” 对象。\n")])])]),v("h2",{attrs:{id:"闭包"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#闭包"}},[n._v("#")]),n._v(" 闭包")]),n._v(" "),v("p",[n._v("指那些能够访问自由变量的函数")]),n._v(" "),v("ol",[v("li",[v("p",[n._v("创建它的执行上下文被销毁了，但它仍然存在（比如内部函数从父函数返回过来）")])]),n._v(" "),v("li",[v("p",[n._v("在代码中引用了自由变量")])])]),n._v(" "),v("p",[n._v("因为闭包能访问以及销毁它但执行上下文访问到变量。而这个变量是无法被销毁的，存储在内存中。\n"),n._v("\n\x3c!-- ```\nfunction aaa () {\nwindow.a = function () {\naaa\n}\n}")]),n._v(" "),v("div",{staticClass:"language---\x3e extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[n._v("\n## 参数按值传递\n\n参数传递都是按值来传递的，但是js中有分``基本类型和引用类型``，所说的值传递是指栈中的值拷贝\n\n基本类型是存储在栈内存中，但引用类型是将地址存在栈内存中，而数据存在堆内存中\n\n## JavaScript 语言在引擎级别的执行过程\n\n### 一、环境的准备\n\n1. 作用域 Scope\n\n作用域本身有两个成员，object 和 parent，作用域中包含对象及属性\n作用域主要有两项功能\n * 查找名字\n * 如果没有，查找 parent 上一层\n\n2. 环境 Environment\n\n词法环境规范：环境记录和 outer，环境记录可以映射为作用域中的 object，outer 映射为作用域中的 parent\n\n3. 属性标识符\n\nES5的重要规范是**属性描述符和属性标识符规范**， 所有的环境记录对外统一用一个有意义的`interface`, 即标识符引用 GetIdentifierReference\n\n标识符引用的所用是代替作用域查找名字的功能，统一格式\n\n### 二. 可执行上下文 Executive Context\n\n执行上下文添加了两个成员，**词法环境**和**变量环境**\n\n理论上**词法环境**和**变量环境**只需要有一个就可以查找名字。但 JavaScript 中变量环境解决 `var` 声明，词法环境解决一般**变量声明**，两种声明在 `JavaScript` 中不兼容\n\n1.代码层面如何 run\n\n执行栈（ECS）为空时，会自动去找任务队列中的函数，并且执行，执行栈是先进后出的原则，任务队列是先进先出的原则\n\n一开始，会执行1. 内核引擎所需要执行上下文（newContext for job），之后2. 通过newContext创建` scriptContext`执行上下文(变量环境和词法环境)\n\nScriptContext 执行上下文具体还可分为四种可执行的上下文，全局初始化、模块初始化环境、实例化函数环境、实例化 Eval 环境等。\n\n1. 执行表达式\n执行表达式返回的结果包括原始值，对象，引用规范类型。\n\n2. 执行语句\n执行语句返回的结果是完整规范类型，表示语句是否被完整执行，是否中断，返\n回值不包含引用。\n\n## 继承\n\n### 原型链继承\n\n原理：child.prototype = new Parent()\n\n1. 引用类型的属性会被所有实例共享\n\n2. 在创建实例的时候，不能向父级构造函数传参\n\n3. 不能实现多继承\n\n### 构造函数继承\n\n原理：Parent.call(this)\n\n**优点**\n\n1. 避免引用类型属性被所有实例共享\n\n2. 创建实例的时候可以传入参数\n\n3. 多继承\n\n**缺点**\n\n方法都定义在构造器中，每次创建实例，会创建一边方法\n\n### 组合(原型链和构造函数)继承\n\n融合原型链和构造函数都优点\n\n缺点\n调用两次父构造函数\n\n")])])]),v("p",[n._v("function Parent (name) {\nthis.name = name;\nthis.colors = ['red', 'blue', 'green'];\n}")]),n._v(" "),v("p",[n._v("Parent.prototype.getName = function () {\nconsole.log(this.name)\n}")]),n._v(" "),v("p",[n._v("function Child (name, age) {")]),n._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",[v("code",[n._v("Parent.call(this, name);\nthis.age = age;\n")])])]),v("p",[n._v("}")]),n._v(" "),v("p",[n._v("Child.prototype = new Parent();\nChild.prototype.constructor = Child;")]),n._v(" "),v("p",[n._v("var child1 = new Child('kevin', '18');")]),n._v(" "),v("p",[n._v("child1.colors.push('black');")]),n._v(" "),v("p",[n._v('console.log(child1.name); // kevin\nconsole.log(child1.age); // 18\nconsole.log(child1.colors); // ["red", "blue", "green", "black"]')]),n._v(" "),v("p",[n._v("var child2 = new Child('daisy', '20');")]),n._v(" "),v("p",[n._v('console.log(child2.name); // daisy\nconsole.log(child2.age); // 20\nconsole.log(child2.colors); // ["red", "blue", "green"]')]),n._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[n._v("\n### 原型式继承\n\n缺点 引用类型属性共享在实例中，和原型链继承一样\n")])])]),v("p",[n._v("Object.create\nfunction createObj(o) {\nfunction F(){}\nF.prototype = o;\nreturn new F();\n}")]),n._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[n._v("\n### 寄生式继承\n\n缺点 跟借用构造函数模式一样，每次创建对象都会创建一遍方法\n")])])]),v("p",[n._v("function createObj (o) {\nvar clone = Object.create(o);\nclone.sayName = function () {\nconsole.log('hi');\n}\nreturn clone;\n}")]),n._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[n._v("\n### 寄生组合式继承\n\n它只调用了一次 Parent 构造函数")])])])])}),[],!1,null,null,null);t.default=a.exports}}]);