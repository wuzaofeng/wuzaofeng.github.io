(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{209:function(e,a,t){e.exports=t.p+"assets/img/1.bd1f492b.jpg"},210:function(e,a,t){e.exports=t.p+"assets/img/2.953fe389.jpg"},211:function(e,a,t){e.exports=t.p+"assets/img/3.7153636f.jpg"},236:function(e,a,t){"use strict";t.r(a);var s=t(0),r=Object(s.a)({},(function(){var e=this,a=e.$createElement,s=e._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"企业级-webpack-分享总结-内附完整ppt"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#企业级-webpack-分享总结-内附完整ppt"}},[e._v("#")]),e._v(" 企业级 Webpack 分享总结(内附完整ppt)")]),e._v(" "),s("h2",{attrs:{id:"基本打包机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基本打包机制"}},[e._v("#")]),e._v(" 基本打包机制")]),e._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[e._v("解释")]),e._v(" "),s("p",[e._v("本质上，webpack 是一个现代 JavaScript 应用程序的"),s("strong",[e._v("静态模块打包器")]),e._v("("),s("code",[e._v("module bundler")]),e._v(")。当 webpack 处理应用程序时，它会"),s("strong",[e._v("递归地构建")]),e._v("一个"),s("strong",[e._v("依赖关系图")]),e._v("("),s("code",[e._v("dependency graph")]),e._v(")，其中包含应用程序需要的每个模块，然后将所有这些模块"),s("strong",[e._v("打包")]),e._v("成一个或多个"),s("code",[e._v("bundle")])])]),e._v(" "),s("p",[e._v("打包过程可以拆分为"),s("strong",[e._v("四步")])]),e._v(" "),s("ol",[s("li",[s("p",[e._v("利用"),s("code",[e._v("babel")]),e._v("完成代码"),s("strong",[e._v("转换")]),e._v(",并生成单个文件的"),s("strong",[e._v("依赖")])])]),e._v(" "),s("li",[s("p",[e._v("从入口"),s("strong",[e._v("开始递归分析")]),e._v("，并"),s("strong",[e._v("生成依赖图谱")])])]),e._v(" "),s("li",[s("p",[e._v("将各个"),s("strong",[e._v("引用模块打包")]),e._v("为一个"),s("strong",[e._v("立即执行函数")])])]),e._v(" "),s("li",[s("p",[e._v("将最终的"),s("code",[e._v("bundle")]),e._v("文件写入"),s("code",[e._v("bundle.js")]),e._v("中")])])]),e._v(" "),s("p",[e._v("完整代码见：https://github.com/LuckyWinty/blog/tree/master/code/bundleBuild")]),e._v(" "),s("h2",{attrs:{id:"打包过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#打包过程"}},[e._v("#")]),e._v(" 打包过程")]),e._v(" "),s("p",[e._v("以上是打包的基本机制，而webpack的"),s("strong",[e._v("打包过程")]),e._v("，会基于这些基本步骤进行扩展，主要有以下步骤：")]),e._v(" "),s("ol",[s("li",[s("p",[s("strong",[e._v("初始化参数")]),e._v(" 从配置文件和 Shell 语句中"),s("strong",[e._v("读取与合并")]),e._v("参数，得出"),s("strong",[e._v("最终的参数")])])]),e._v(" "),s("li",[s("p",[s("strong",[e._v("开始编译")]),e._v(" 用上一步得到的参数初始"),s("strong",[e._v("Compiler对象")]),e._v("，"),s("strong",[e._v("加载所有配置的插件")]),e._v("，通 过执行对象的run方法开始执行编译")])]),e._v(" "),s("li",[s("p",[s("strong",[e._v("确定入口")]),e._v(" 根据配置中的 Entry 找出所有入口文件")])]),e._v(" "),s("li",[s("p",[s("strong",[e._v("编译模块")]),e._v(" 从入口文件出发，调用所有配置的 "),s("code",[e._v("Loader")]),e._v(" 对模块进行编译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理")])]),e._v(" "),s("li",[s("p",[s("strong",[e._v("完成模块编译")]),e._v(" 在经过第4步使用 Loader 翻译完所有模块后， 得到了每个模块被编译后的最终内容及它们之间的"),s("strong",[e._v("依赖关系")])])]),e._v(" "),s("li",[s("p",[s("strong",[e._v("输出资源")]),e._v("：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 "),s("code",[e._v("Chunk")]),e._v(",再将每个 "),s("code",[e._v("Chunk")]),e._v(" 转换成一个单独的文件加入"),s("strong",[e._v("输出列表")]),e._v("中，这是可以修改输出内容的最后机会")])]),e._v(" "),s("li",[s("p",[s("strong",[e._v("输出完成")]),e._v("：在确定好输出内容后，根据"),s("strong",[e._v("配置确定输出的路径和文件名")]),e._v("，将文件的内容写入文件系统中")])])]),e._v(" "),s("p",[e._v("整个流程概括为3个阶段，"),s("strong",[e._v("初始化、编译、输出")]),e._v("。而在每个阶段中又会发生很多事件，Webpack会将这些事件广播出来供Plugin使用。具体钩子\n可以看官方文档：https://webpack.js.org/api/compiler-hooks/#hooks")]),e._v(" "),s("p",[s("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=MzI0MzIyMDM5Ng%3D%3D&chksm=f175e83bc602612d32a2568bfb74f4a9f762b058e9ba39d976c355ae916c27bca73c9fa3d65a&idx=1&mid=2649826040&scene=21&sn=d00485f9421520699740404f8ecf3302#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("Webpack4打包机制原理解析"),s("OutboundLink")],1)]),e._v(" "),s("h2",{attrs:{id:"webpack-loader"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#webpack-loader"}},[e._v("#")]),e._v(" Webpack Loader")]),e._v(" "),s("p",[e._v("Loader 就像一个翻译员，能将源文件经过转化后输出新的结果，并且一个文件还可以链式地经过多个翻译员翻译")]),e._v(" "),s("h3",{attrs:{id:"概念"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[e._v("#")]),e._v(" 概念")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("一个Loader 的职责是单一的，只需要完成一种转换")])]),e._v(" "),s("li",[s("p",[e._v("一个Loader 其实就是一个Node.js 模块，这个模块需要导出一个函数")])])]),e._v(" "),s("h3",{attrs:{id:"开发loader形式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#开发loader形式"}},[e._v("#")]),e._v(" 开发Loader形式")]),e._v(" "),s("ul",[s("li",[e._v("基本形式")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("module.exports = function (source ) {\n    return source;\n}\n")])])]),s("ul",[s("li",[e._v("调用第三方模块")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("const sass= require('node-sass');\nmodule.exports = function (source) {\n  return sass(source);\n}\n")])])]),s("p",[e._v("由于 "),s("code",[e._v("Loader")]),e._v(" 运行在 Node.js 中，所以我们可以调用任意 Node.js 自带的 API ，或者安装第三方模块进行调用")]),e._v(" "),s("ul",[s("li",[e._v("调用Webpack的Api")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("//获取用户为 Loader 传入的 options\nconst loaderUtils =require ('loader-utils');\nmodule.exports = (source) => {\n    const options= loaderUtils.getOptions(this);\n    return source;\n}\n//返回sourceMap\nmodule.exports = (source)=> {\n    this.callback(null, source, sourceMaps);\n    //当我们使用 this.callback 返回内容时 ，该 Loader 必须返回 undefined,\n    //以让 Webpack 知道该 Loader 返回的结果在 this.callback 中，而不是 return中\n    return;\n}\n// 异步\nmodule.exports = (source) => {\n    const callback = this.async()\n    someAsyncOperation(source, (err, result, sourceMaps, ast) => {\n        // 通过 callback 返回异步执行后的结果\n        callback(err, result, sourceMaps, ast)\n    })\n}\n//缓存加速\nmodule.exports = (source) => {\n    //关闭该 Loader 的缓存功能\n    this.cacheable(false)\n    return source\n}\n")])])]),s("p",[e._v("source参数是compiler 传递给 Loader 的一个文件的原内容，这个函数需要返回处理后的内容，这里为了简单起见，直接将原内容返回了，相当于该Loader 有做任何转换.这里结合了webpack的api和第三方模块之后")]),e._v(" "),s("p",[s("a",{attrs:{href:"https://webpack.js.org/api/loaders",target:"_blank",rel:"noopener noreferrer"}},[e._v("更多的webpack Api可以看官方文档"),s("OutboundLink")],1)]),e._v(" "),s("h2",{attrs:{id:"webpack-plugin"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#webpack-plugin"}},[e._v("#")]),e._v(" Webpack Plugin")]),e._v(" "),s("p",[e._v("专注处理 "),s("code",[e._v("webpack")]),e._v(" 在编译过程中的"),s("strong",[e._v("某个特定的任务")]),e._v("的功能模块，可以称为插件概念")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("是一个"),s("strong",[e._v("独立")]),e._v("的模块")])]),e._v(" "),s("li",[s("p",[e._v("模块对"),s("strong",[e._v("外暴露一个 js 函数")])])]),e._v(" "),s("li",[s("p",[e._v("函数的原型 (prototype) 上定义了一个注入 "),s("code",[e._v("compiler")]),e._v(" 对象的 apply 方法 apply 函数中需要有通过 "),s("code",[e._v("compiler")]),e._v(" 对象挂载的 "),s("code",[e._v("webpack")]),e._v(" 事件钩子，钩子的回调中能拿到当前编译的 "),s("code",[e._v("compilation")]),e._v("对象，如果是异步编译插件的话可以拿到回调 callback")])]),e._v(" "),s("li",[s("p",[e._v("完成自定义子编译流程并处理 "),s("code",[e._v("complition")]),e._v(" 对象的内部数据")])]),e._v(" "),s("li",[s("p",[e._v("如果异步编译插件的话，数据处理完成后执行 callback 回调")])])]),e._v(" "),s("h3",{attrs:{id:"开发基本形式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#开发基本形式"}},[e._v("#")]),e._v(" 开发基本形式")]),e._v(" "),s("p",[e._v("Webpack 启动后，在读取配置的过程中会先执行 "),s("code",[e._v("new BasicPlugin(options)")]),e._v("初始化一个 "),s("code",[e._v("BasicPlugin")]),e._v(" 并获得其实例。在初始化 "),s("code",[e._v("Compiler")]),e._v(" 对象后，再调用 "),s("code",[e._v("basicPlugin.apply (compiler）")]),e._v("为插件实例传入 "),s("code",[e._v("compiler")]),e._v(" 对象。插件实例在获取到 "),s("code",[e._v("compiler")]),e._v(" 对象后，就可以通过 "),s("code",[e._v("compiler")]),e._v(". plugin （事件名称 ，回调函数）监听到 Webpack 广播的事件，并且可以通过 compiler 对象去操作 Webpack。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// 1、BasicPlugin.js 文件（独立模块）\n    // 2、模块对外暴露的 js 函数\n    class BasicPlugin{\n        //在构造函数中获取用户为该插件传入的配置\n        constructor(pluginOptions) {\n            this.options = pluginOptions;\n        }\n        //3、原型定义一个 apply 函数，并注入了 compiler 对象\n        apply(compiler) {\n            //4、挂载 webpack 事件钩子（这里挂载的是 emit 事件）\n            compiler.plugin('emit', function (compilation, callback) {\n                // ... 内部进行自定义的编译操作\n                // 5、操作 compilation 对象的内部数据\n                console.log(compilation);\n                // 6、执行 callback 回调\n                callback();\n            });\n        }\n    }\n// 7、暴露 js 函数\nmodule.exports = BasicPlugin;\n")])])]),s("h3",{attrs:{id:"compiler对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#compiler对象"}},[e._v("#")]),e._v(" Compiler对象")]),e._v(" "),s("p",[e._v("compiler对象是 webpack 的"),s("strong",[e._v("编译器")]),e._v("对象，compiler对象会在启动 webpack 的时候被一次性地初始化，"),s("strong",[e._v("compiler对象")]),e._v("中包含了所有 webpack "),s("strong",[e._v("可自定义操作的配置")]),e._v("，例如 loader 的配置，plugin 的配置，entry的配置等各种原始 webpack 配置")]),e._v(" "),s("p",[s("img",{attrs:{src:t(209),alt:"compiler对象"}})]),e._v(" "),s("p",[e._v("webpack部分源码：https://github.com/webpack/webpack/blob/10282ea20648b465caec6448849f24fc34e1ba3e/lib/webpack.js#L30")]),e._v(" "),s("h3",{attrs:{id:"compilation-对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#compilation-对象"}},[e._v("#")]),e._v(" Compilation 对象")]),e._v(" "),s("p",[e._v("compilation 实例继承于 compiler，compilation 对象代表了一次单一的版本 webpack 构建和生成编译资源的过程。当运行 webpack 开发环境中间件时，"),s("strong",[e._v("每当检测到一个文件变化，一次新的编译将被创建，从而生成一组新的编译资源以及新的 compilation 对象")]),e._v("。一个 compilation 对象包含了 当前的模块资源、编译生成资源、变化的文件、以及 被跟踪依赖的状态信息。编译对象也提供了很多关键点回调供插件做自定义处理时选择使用。")]),e._v(" "),s("p",[e._v("Compiler 和 Compilation 的区别在于："),s("strong",[e._v("Compiler 代表了整个 Webpack 从启动到关闭的生命周期，而 Compilation 只代表一次新的编译")])]),e._v(" "),s("h3",{attrs:{id:"tapable-tapable-实例"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tapable-tapable-实例"}},[e._v("#")]),e._v(" Tapable & Tapable 实例")]),e._v(" "),s("p",[e._v("webpack 的插件架构主要基于 Tapable 实现的，Tapable 是 webpack 项目组的一个内部库，主要是抽象了一套插件机制。它类似于 "),s("code",[e._v("NodeJS")]),e._v(" 的 "),s("code",[e._v("EventEmitter")]),e._v(" 类，专注于自定义事件的触发和操作。除此之外, Tapable 允许你通过回调函数的参数访问事件的生产者")]),e._v(" "),s("p",[s("img",{attrs:{src:t(210),alt:"Tapable"}})]),e._v(" "),s("p",[e._v("webpack本质上是一种事件流的机制，它的工作流程就是将"),s("strong",[e._v("各个插件串联起来")]),e._v("，而实现这一切的核心就是Tapable，webpack中最核心的"),s("strong",[e._v("负责编译的Compiler和负责创建bundles的Compilation都是Tapable的实例")]),e._v("，Tapable 能够让我们为 javaScript 模块添加并应用插件。它可以被其它模块继承或混合。")]),e._v(" "),s("h3",{attrs:{id:"tapable-模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tapable-模型"}},[e._v("#")]),e._v(" Tapable 模型")]),e._v(" "),s("p",[e._v("Tapable 简化后的模型，就是我们熟悉的发布订阅者模式")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("\nclass SyncHook{\n   constructor(){\n      this.hooks = {}\n   }\n   \n   tap(name,fn){\n    if(!this.hooks[name])this.hooks[name] = []\n     this.hooks[name].push(fn)\n   }\n \n   call(name){\n     this.hooks[name].forEach(hook=>hook(...arguments))\n   }\n}\n")])])]),s("p",[s("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=MzI0MzIyMDM5Ng%3D%3D&chksm=f175e8cdc60261db3c0caa44fd58e8d759526e5bb5b6e2caebba957a5996931cc68c18e69d37&idx=1&mid=2649825806&scene=21&sn=e46dbd274e240c4dcc4b778d8b30c67d#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("webpack 插件机制分析及开发调试"),s("OutboundLink")],1)]),e._v(" "),s("h2",{attrs:{id:"构建工具选择"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#构建工具选择"}},[e._v("#")]),e._v(" 构建工具选择")]),e._v(" "),s("p",[e._v("针对不同的场景，选择最合适的工具")]),e._v(" "),s("p",[s("img",{attrs:{src:t(211),alt:"构建工具选择"}})]),e._v(" "),s("p",[e._v("通过对比，不难看出，"),s("strong",[e._v("Webpack")]),e._v("和"),s("strong",[e._v("Rollup")]),e._v("在不同场景下，都能发挥自身优势作用。webpack作为打包工具，但是在定义模块输出的时候，webpack确不支持ESM，webpack插件系统庞大，确实有支持模块级的"),s("code",[e._v("Tree-Shacking")]),e._v("的插件，如"),s("code",[e._v("webpack-deep-scope-analysis-plugin")]),e._v("。但是粒度更细化的，一个模块里面的某个方法，本来如果没有被引用的话也可以去掉的，就不行了....这个时候，就要上rollup了。rollup它"),s("strong",[e._v("支持程序流分析")]),e._v("，能更加正确的判断项目本身的代码是否有副作用，其实就是rollup的"),s("code",[e._v("tree-shaking")]),e._v("更干净。所以我们的结论是"),s("strong",[e._v("rollup 比较适合打包 js 的 sdk 或者封装的框架")]),e._v("等，例如，vue 源码就是 rollup 打包的。而 webpack 比较适合打包一些应用，例如"),s("strong",[e._v("SPA 或者同构项目")]),e._v("等等。")]),e._v(" "),s("p",[e._v("结论:在开发应用时使用 "),s("strong",[e._v("Webpack")]),e._v("，开发库时使用 "),s("strong",[e._v("Rollup")])]),e._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[e._v("参考链接")]),e._v(" "),s("p",[e._v("来源：winty https://blog.csdn.net/LuckyWinty/article/details/103590665")]),e._v(" "),s("p",[s("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=MzI0MzIyMDM5Ng%3D%3D&chksm=f175e83bc602612d32a2568bfb74f4a9f762b058e9ba39d976c355ae916c27bca73c9fa3d65a&idx=1&mid=2649826040&scene=21&sn=d00485f9421520699740404f8ecf3302#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("Webpack4打包机制原理解析"),s("OutboundLink")],1)]),e._v(" "),s("p",[s("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=MzI0MzIyMDM5Ng%3D%3D&chksm=f175e8cdc60261db3c0caa44fd58e8d759526e5bb5b6e2caebba957a5996931cc68c18e69d37&idx=1&mid=2649825806&scene=21&sn=e46dbd274e240c4dcc4b778d8b30c67d#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("webpack 插件机制分析及开发调试"),s("OutboundLink")],1)]),e._v(" "),s("p",[s("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=MzI0MzIyMDM5Ng%3D%3D&chksm=f175eb16c6026200933472fd8f4b8d46b725f072608c2fe4fe11c1ccd78a563d21e0e9ab9a47&idx=1&mid=2649825749&scene=21&sn=c9528c31aa54836e2e3754ff93913e1b#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("webpack中的HMR(热更新)原理剖析"),s("OutboundLink")],1)]),e._v(" "),s("p",[s("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=MzI0MzIyMDM5Ng%3D%3D&chksm=f175eb1cc602620a66821baedcb2663e393f7ae4857e8daf6d57e4c436f9a7297a555d0e4750&idx=1&mid=2649825759&scene=21&sn=726279d3dfc2ea0b6ba34788517753ad#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("Webpack性能优化总结大全"),s("OutboundLink")],1)])])])}),[],!1,null,null,null);a.default=r.exports}}]);